I"b¯<h1 id="æ­£æ–‡">æ­£æ–‡</h1>
<h2 id="introduction">Introduction</h2>

<h3 id="getting-started">Getting Started</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git pull
Already up-to-date.
<span class="nv">$ </span>git checkout <span class="nt">-b</span> lab3 origin/lab3
Branch lab3 <span class="nb">set </span>up to track remote branch lab3 from origin.
Switched to a new branch <span class="s1">'lab3'</span>
<span class="nv">$ </span>git merge lab2
Auto-merging kern/pmap.c
Auto-merging kern/monitor.c
Auto-merging kern/kdebug.c
Merge made by the <span class="s1">'recursive'</span> strategy.
 kern/console.c |   2 +-
 kern/kdebug.c  |   8 +++--
 kern/monitor.c |  22 ++++++++++++-
 kern/pmap.c    | 196 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--------
 lib/printfmt.c |   7 ++--
 5 files changed, 214 insertions<span class="o">(</span>+<span class="o">)</span>, 21 deletions<span class="o">(</span>-<span class="o">)</span>
</code></pre></div></div>

<h3 id="lab-requirements">Lab Requirements</h3>
<p>è¦æ±‚åŒ lab 2ã€‚</p>

<h3 id="inline-assembly">Inline Assembly</h3>
<p>åœ¨è¿™ä¸ª lab ä¸­ï¼ŒGCC çš„å†…åµŒæ±‡ç¼–å¯èƒ½ä¼šæ¯”è¾ƒå¥½ä½¿ï¼Œä½†æ˜¯ä¹Ÿå¯ä»¥ä¸ç”¨ã€‚</p>

<h2 id="part-a-user-environments-and-exception-handling">Part A. User Environments and Exception Handling</h2>
<p>inc/env.h:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* See COPYRIGHT for copyright information. */</span>

<span class="cp">#ifndef JOS_INC_ENV_H
#define JOS_INC_ENV_H
</span>
<span class="cp">#include &lt;inc/types.h&gt;
#include &lt;inc/trap.h&gt;
#include &lt;inc/memlayout.h&gt;
</span>
<span class="k">typedef</span> <span class="kt">int32_t</span> <span class="n">envid_t</span><span class="p">;</span>

<span class="c1">// An environment ID 'envid_t' has three parts:</span>
<span class="c1">//</span>
<span class="c1">// +1+---------------21-----------------+--------10--------+</span>
<span class="c1">// |0|          Uniqueifier             |   Environment    |</span>
<span class="c1">// | |                                  |      Index       |</span>
<span class="c1">// +------------------------------------+------------------+</span>
<span class="c1">//                                       \--- ENVX(eid) --/</span>
<span class="c1">//</span>
<span class="c1">// The environment index ENVX(eid) equals the environment's index in the</span>
<span class="c1">// 'envs[]' array.  The uniqueifier distinguishes environments that were</span>
<span class="c1">// created at different times, but share the same environment index.</span>
<span class="c1">//</span>
<span class="c1">// All real environments are greater than 0 (so the sign bit is zero).</span>
<span class="c1">// envid_ts less than 0 signify errors.  The envid_t == 0 is special, and</span>
<span class="c1">// stands for the current environment.</span>

<span class="cp">#define LOG2NENV                10
#define NENV                    (1 &lt;&lt; LOG2NENV)
#define ENVX(envid)             ((envid) &amp; (NENV - 1))
</span>
<span class="c1">// Values of env_status in struct Env</span>
<span class="k">enum</span> <span class="p">{</span>
        <span class="n">ENV_FREE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">ENV_DYING</span><span class="p">,</span>
        <span class="n">ENV_RUNNABLE</span><span class="p">,</span>
        <span class="n">ENV_RUNNING</span><span class="p">,</span>
        <span class="n">ENV_NOT_RUNNABLE</span>
<span class="p">};</span>

<span class="c1">// Special environment types</span>
<span class="k">enum</span> <span class="n">EnvType</span> <span class="p">{</span>
        <span class="n">ENV_TYPE_USER</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Env</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Trapframe</span> <span class="n">env_tf</span><span class="p">;</span>        <span class="c1">// Saved registers</span>
        <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env_link</span><span class="p">;</span>           <span class="c1">// Next free Env</span>
        <span class="n">envid_t</span> <span class="n">env_id</span><span class="p">;</span>                 <span class="c1">// Unique environment identifier</span>
        <span class="n">envid_t</span> <span class="n">env_parent_id</span><span class="p">;</span>          <span class="c1">// env_id of this env's parent</span>
        <span class="k">enum</span> <span class="n">EnvType</span> <span class="n">env_type</span><span class="p">;</span>          <span class="c1">// Indicates special system environments</span>
        <span class="kt">unsigned</span> <span class="n">env_status</span><span class="p">;</span>            <span class="c1">// Status of the environment</span>
        <span class="kt">uint32_t</span> <span class="n">env_runs</span><span class="p">;</span>              <span class="c1">// Number of times environment has run</span>

        <span class="c1">// Address space</span>
        <span class="n">pde_t</span> <span class="o">*</span><span class="n">env_pgdir</span><span class="p">;</span>               <span class="c1">// Kernel virtual address of page dir</span>

<span class="p">};</span>
<span class="cp">#endif // !JOS_INC_ENV_H
</span></code></pre></div></div>
<p>è§‚å¯Ÿä¸€ä¸‹å¯ä»¥å‘ç° Environmrnt Index çš„å–å€¼èŒƒå›´æ˜¯ $[0,2^{10})$. è¿™ä¹Ÿå°±æ˜¯ <code class="language-plaintext highlighter-rouge">envs[]</code> æ•°ç»„çš„ç´¢å¼•èŒƒå›´ã€‚<br />
Uniqueifier å”¯ä¸€ç¬¦å¯ä»¥åœ¨ä¸åŒæ¬¡åˆ›å»ºæ—¶åŒºåˆ†ç¯å¢ƒã€‚<br />
æ‰€æœ‰çš„å®ç¯å¢ƒçš„çš„ç¬¦å·ä½éƒ½æ˜¯ 0, å³å¤§äº 0.</p>

<p>æ¥ç€æ˜¯ä¸¤ä¸ªæšä¸¾ç±»å‹ã€‚ä¸€ä¸ªæ˜¯è¡¨ç¤º <code class="language-plaintext highlighter-rouge">struct Env</code> ä¸­çš„ <code class="language-plaintext highlighter-rouge">env_status</code> åŸŸï¼Œåˆ†åˆ«ä¸ºç©ºé—²ã€æ­»äº¡ã€å¯è¿è¡Œã€æ­£åœ¨è¿è¡Œã€ä¸å¯è¿è¡Œï¼›ç¬¬äºŒä¸ªç”¨æ¥æŒ‡ç¤ºç‰¹æ®Šç³»ç»Ÿç¯å¢ƒï¼Œå¯¹åº” <code class="language-plaintext highlighter-rouge">struct Env</code> ä¸­çš„ <code class="language-plaintext highlighter-rouge">env_type</code> åŸŸã€‚</p>

<p>In <code class="language-plaintext highlighter-rouge">kern/env.c</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">envs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                <span class="c1">// All environments</span>
<span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">curenv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>              <span class="c1">// The current env</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">env_free_list</span><span class="p">;</span>       <span class="c1">// Free environment list</span>
                                        <span class="c1">// (linked by Env-&gt;env_link)</span>
</code></pre></div></div>
<p>ä¸‰ä¸ª <code class="language-plaintext highlighter-rouge">struct Env</code> æŒ‡é’ˆï¼Œç¬¬ä¸€ä¸ªæ˜¯æ‰€æœ‰ç¯å¢ƒï¼Œç›®æµ‹åº”è¯¥æ˜¯æŒ‡å‘æ‰€æœ‰ç¯å¢ƒé¦–èŠ‚ç‚¹ï¼›ç¬¬äºŒä¸ªæŒ‡å‘å½“å‰æ‰§è¡Œçš„ç¯å¢ƒ(currently executing environment)ï¼›ç¬¬ä¸‰ä¸ªæŒ‡å‘ç©ºé—²ç¯å¢ƒçš„é¦–èŠ‚ç‚¹ã€‚ä¸‹é¢è¿˜æœ‰è¡Œæ³¨é‡Šï¼Œè¿™äº›èŠ‚ç‚¹é  <code class="language-plaintext highlighter-rouge">struct Env</code> çš„ <code class="language-plaintext highlighter-rouge">env_link</code> åŸŸé“¾æ¥ã€‚</p>

<p>åœ¨ <code class="language-plaintext highlighter-rouge">inc/env.h</code> ä¸­å®šä¹‰çš„ <code class="language-plaintext highlighter-rouge">NENV</code> æ˜¯ JOS ä¸­åŒæ—¶æ¿€æ´»çš„ç¯å¢ƒæ•°ä¸Šé™ï¼Œè·Ÿæˆ‘ä»¬ä¸Šé¢çš„çŒœæµ‹æ˜¯ä¸€æ ·çš„ã€‚</p>

<h3 id="environment-state">Environment State</h3>
<p>æ¥ç€æ¥çœ‹å¯¹ <code class="language-plaintext highlighter-rouge">struct Env</code> åŸŸçš„ä»‹ç»ï¼š<br />
<code class="language-plaintext highlighter-rouge">env_tf</code>: ä¸€ä¸ª <code class="language-plaintext highlighter-rouge">struct Trapframe</code> å¯¹è±¡ï¼Œåœ¨ <code class="language-plaintext highlighter-rouge">inc/trap.h</code> ä¸­å®šä¹‰ã€‚åœ¨ç¯å¢ƒæœªè¿è¡Œæ—¶ä¸ºç¯å¢ƒä¿å­˜å¯„å­˜å™¨å€¼ã€‚è¿™æ˜¯ä¸ºäº†æ–¹ä¾¿åœ¨ä¸åŒç¯å¢ƒä¹‹é—´è·³è½¬ã€‚<br />
<code class="language-plaintext highlighter-rouge">struct Trapframe</code> çš„å®šä¹‰ï¼š<br />
In <code class="language-plaintext highlighter-rouge">inc/trap.h</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Trapframe</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">PushRegs</span> <span class="n">tf_regs</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">tf_es</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">tf_padding1</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">tf_ds</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">tf_padding2</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">tf_trapno</span><span class="p">;</span>
        <span class="cm">/* below here defined by x86 hardware */</span>
        <span class="kt">uint32_t</span> <span class="n">tf_err</span><span class="p">;</span>
        <span class="kt">uintptr_t</span> <span class="n">tf_eip</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">tf_cs</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">tf_padding3</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">tf_eflags</span><span class="p">;</span>
        <span class="cm">/* below here only when crossing rings, such as from user to kernel */</span>
        <span class="kt">uintptr_t</span> <span class="n">tf_esp</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">tf_ss</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">tf_padding4</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">env_link</code>: å¯ç”¨ç¯å¢ƒåˆ—è¡¨ä¸­æŒ‡å‘ä¸‹ä¸€é¡¹çš„æŒ‡é’ˆï¼›<br />
<code class="language-plaintext highlighter-rouge">env_id</code>: å½“å‰ä½¿ç”¨çš„ <code class="language-plaintext highlighter-rouge">Env</code> ç»“æ„ä½“éœ€è¦ä¸€ä¸ªå”¯ä¸€çš„æ ‡è¯†ç¬¦ã€‚å½“ç”¨æˆ·ç¯å¢ƒç»ˆæ­¢ä¹‹åï¼Œkernel å¯èƒ½ä¼šå°†è¿™ä¸ªç¯å¢ƒé‡æ–°åˆ†é…ç»™å¦å¤–ä¸€ä¸ªç¯å¢ƒï¼Œè¿™æ—¶å€™åªéœ€è¦æ”¹å˜ <code class="language-plaintext highlighter-rouge">env_id</code> å°±å¯ä»¥äº†ï¼›<br />
<code class="language-plaintext highlighter-rouge">env_parent_id</code>: kernel ç”¨æ¥å­˜å‚¨åˆ›é€ äº†å½“å‰ç¯å¢ƒçš„ç¯å¢ƒçš„ idï¼Œä¹Ÿå°±æ˜¯å®ƒçš„çˆ¶ç¯å¢ƒã€‚ä½¿ç”¨è¿™ç§æ–¹å¼å¯ä»¥æ„å»ºä¸€ä¸ªâ€œå®¶æ—æ ‘â€ï¼ˆç±»ä¼¼äºå›æº¯è·¯å¾„ï¼‰ï¼Œå®¶æ—æ ‘ç®—æ˜¯ä¸€ä¸ªç®¡ç†æƒé™çš„æ–¹å¼ï¼›<br />
<code class="language-plaintext highlighter-rouge">env_type</code>: ç”¨äºåŒºåˆ†ç‰¹æ®Šç¯å¢ƒã€‚å¯¹äºå¤§å¤šæ•°ç¯å¢ƒï¼Œè¯¥åŸŸçš„å€¼ä¸º <code class="language-plaintext highlighter-rouge">ENV_TYPE_USER</code>; <br />
<code class="language-plaintext highlighter-rouge">env_status</code>: è¡¨ç¤ºçŠ¶æ€ï¼š</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ENV_FREE</code>: è¡¨ç¤ºç¯å¢ƒæœªæ¿€æ´»ï¼Œåº”åœ¨ <code class="language-plaintext highlighter-rouge">env_free_list</code> ä¸­ï¼›</li>
  <li><code class="language-plaintext highlighter-rouge">ENV_RUNNABLE</code>: è¡¨ç¤ºå¾…æœºï¼ˆç­‰å¾…å¤„ç†å™¨æ‰§è¡Œï¼‰çš„ç¯å¢ƒï¼›</li>
  <li><code class="language-plaintext highlighter-rouge">ENV_RUNNING</code>: è¡¨ç¤ºæ­£åœ¨è¿è¡Œçš„ç¯å¢ƒï¼›</li>
  <li><code class="language-plaintext highlighter-rouge">ENV_NOT_RUNNABLE</code>: è¡¨ç¤ºä¸€ä¸ªå·²ç»æ¿€æ´»çš„ç¯å¢ƒï¼Œä½†æ˜¯ä¸åœ¨å¾…æœºï¼›</li>
  <li><code class="language-plaintext highlighter-rouge">ENV_DYING</code>: è¡¨ç¤ºä¸€ä¸ªåƒµå°¸ç¯å¢ƒï¼Œå°†åœ¨è§¦å‘åˆ° kernel åè¢«é‡Šæ”¾ã€‚lab 4 ä¸­æ‰ä¼šç”¨ä¸Šã€‚</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">env_pgdir</code>: å­˜æ”¾ç¯å¢ƒé¡µç›®å½•çš„ KVA.</p>

<h3 id="allocating-the-environments-array">Allocating the Environments Array</h3>
<p>åœ¨ lab 2 ä¸­æˆ‘ä»¬å·²ç»ç¼–å†™äº† <code class="language-plaintext highlighter-rouge">mem_init()</code> å‡½æ•°å»å®Œæˆ <code class="language-plaintext highlighter-rouge">pages[]</code> æ•°ç»„çš„åˆ†é…ã€‚å¢åŠ ä»£ç ï¼Œå®Œæˆå¯¹ <code class="language-plaintext highlighter-rouge">envs</code> çš„åˆ†é…ã€‚<br />
è§ Exercise 1.</p>

<h3 id="creating-and-running-environments">Creating and Running Environments</h3>
<p>åŸæ–‡æç¤ºæˆ‘ä»¬ä¸€äº›é™æ€çš„äºŒè¿›åˆ¶é•œåƒåµŒå…¥åˆ°äº†å†…æ ¸é‡Œé¢ï¼Œè¯¦è§ <code class="language-plaintext highlighter-rouge">GNUmakefile</code> å’Œ <code class="language-plaintext highlighter-rouge">kern/Makefrag</code>.<br />
<code class="language-plaintext highlighter-rouge">i386_init()</code> å‡½æ•°ä¸­æ–°åŠ å…¥äº† <code class="language-plaintext highlighter-rouge">env_init()</code> å’Œ <code class="language-plaintext highlighter-rouge">trap_init()</code> çš„è°ƒç”¨ã€‚æˆ‘ä»¬å°†åœ¨ Exercise 2 ä¸­å®ç° env ç›¸å…³çš„ä¸€äº›ä»£ç ã€‚</p>

<p>ç”¨æˆ·ç¯å¢ƒä»£ç è¢«è°ƒç”¨ä¹‹å‰ï¼Œç³»ç»ŸæŒ‰ä¸‹åˆ—é¡ºåºè°ƒç”¨äº†å‡½æ•°ï¼š</p>
<ul>
  <li>start (kern/entry.S)</li>
  <li>i386_init (kern/init.c)</li>
  <li>cons_init
    <ul>
      <li>mem_init</li>
      <li>env_init</li>
      <li>trap_init ï¼ˆæ­¤æ—¶è¿˜æœªå®Œæˆï¼‰</li>
      <li>env_create</li>
      <li>env_run
        <ul>
          <li>env_pop_tf</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="exercise">Exercise</h1>
<h2 id="exercise-1">Exercise 1</h2>
<blockquote>
  <p><strong>Exercise 1.</strong> Modify <code class="language-plaintext highlighter-rouge">mem_init()</code> in <code class="language-plaintext highlighter-rouge">kern/pmap.c</code> to allocate and map the envs array. This array consists of exactly <code class="language-plaintext highlighter-rouge">NENV</code> instances of the Env structure allocated much like how you allocated the pages array. Also like the pages array, the memory backing envs should also be mapped user read-only at <code class="language-plaintext highlighter-rouge">UENVS</code> (defined in <code class="language-plaintext highlighter-rouge">inc/memlayout.h</code>) so user processes can read from this array.</p>

  <p>You should run your code and make sure <code class="language-plaintext highlighter-rouge">check_kern_pgdir()</code> succeeds.</p>
</blockquote>

<p>In <code class="language-plaintext highlighter-rouge">kern/pmap.c</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">//////////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Make 'envs' point to an array of size 'NENV' of 'struct Env'.</span>
        <span class="c1">// LAB 3: Your code here.</span>
        <span class="n">envs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Env</span><span class="o">*</span><span class="p">)</span><span class="n">boot_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span><span class="p">)</span> <span class="o">*</span> <span class="n">NENV</span><span class="p">);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">envs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span><span class="p">)</span> <span class="o">*</span> <span class="n">NENV</span><span class="p">);</span>

        <span class="c1">//////////////////////////////////////////////////////////////////////</span>
        <span class="c1">// Map the 'envs' array read-only by the user at linear address UENVS</span>
        <span class="c1">// (ie. perm = PTE_U | PTE_P).</span>
        <span class="c1">// Permissions:</span>
        <span class="c1">//    - the new image at UENVS  -- kernel R, user R</span>
        <span class="c1">//    - envs itself -- kernel RW, user NONE</span>
        <span class="c1">// LAB 3: Your code here.</span>
        <span class="n">boot_map_region</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">,</span> <span class="n">UENVS</span><span class="p">,</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span><span class="p">)</span> <span class="o">*</span> <span class="n">NENV</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">),</span> <span class="n">PADDR</span><span class="p">(</span><span class="n">envs</span><span class="p">),</span> <span class="n">PTE_U</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="exercise-2">Exercise 2</h2>
<blockquote>
  <p><strong>Exercise 2</strong>. In the file <code class="language-plaintext highlighter-rouge">env.c</code>, finish coding the following functions:</p>

  <p><code class="language-plaintext highlighter-rouge">env_init()</code><br />
    &gt; Initialize all of the <code class="language-plaintext highlighter-rouge">Env</code> structures in the <code class="language-plaintext highlighter-rouge">envs</code> array and add them to the <code class="language-plaintext highlighter-rouge">env_free_list</code>. Also calls <code class="language-plaintext highlighter-rouge">env_init_percpu</code>, which configures the segmentation hardware with separate segments for privilege level 0 (kernel) and privilege level 3 (user).<br />
<code class="language-plaintext highlighter-rouge">env_setup_vm()</code><br />
Allocate a page directory for a new environment and initialize the kernel portion of the new environmentâ€™s address space.<br />
<code class="language-plaintext highlighter-rouge">region_alloc()</code><br />
Allocates and maps physical memory for an environment<br />
<code class="language-plaintext highlighter-rouge">load_icode()</code><br />
You will need to parse an ELF binary image, much like the boot loader already does, and load its contents into the user address space of a new environment.<br />
<code class="language-plaintext highlighter-rouge">env_create()</code><br />
Allocate an environment with <code class="language-plaintext highlighter-rouge">env_alloc</code> and call <code class="language-plaintext highlighter-rouge">load_icode</code> to load an ELF binary into it.<br />
<code class="language-plaintext highlighter-rouge">env_run()</code>  <br />
Start a given environment running in user mode. <br />
As you write these functions, you might find the new cprintf verb %e useful â€“ it prints a description corresponding to an error code. For example,</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	r = -E_NO_MEM;
	panic("env_alloc: %e", r);
</code></pre></div>  </div>
  <p>will panic with the message â€œenv_alloc: out of memoryâ€.</p>
</blockquote>

<p>ç›´æ¥å¼€å§‹å†™ä»£ç ï¼š<br />
In <code class="language-plaintext highlighter-rouge">kern/env.c</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">env_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>       
        <span class="c1">// Set up envs array</span>
        <span class="c1">// LAB 3: Your code here.</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NENV</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">NENV</span><span class="p">)</span>
                        <span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">env_link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
                <span class="k">else</span>
                        <span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">env_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">env_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">envs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">env_status</span> <span class="o">=</span> <span class="n">ENV_FREE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">env_free_list</span> <span class="o">=</span> <span class="n">envs</span><span class="p">;</span>
        <span class="c1">// Per-CPU part of the initialization</span>
        <span class="n">env_init_percpu</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">env_setup_vm</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="c1">// Allocate a page for the page directory</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">page_alloc</span><span class="p">(</span><span class="n">ALLOC_ZERO</span><span class="p">)))</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">E_NO_MEM</span><span class="p">;</span>

        <span class="c1">// Now, set e-&gt;env_pgdir and initialize the page directory.</span>
        <span class="c1">//</span>
        <span class="c1">// Hint:</span>
        <span class="c1">//    - The VA space of all envs is identical above UTOP</span>
        <span class="c1">//      (except at UVPT, which we've set below).</span>
        <span class="c1">//      See inc/memlayout.h for permissions and layout.</span>
        <span class="c1">//      Can you use kern_pgdir as a template?  Hint: Yes.</span>
        <span class="c1">//      (Make sure you got the permissions right in Lab 2.)</span>
        <span class="c1">//    - The initial VA below UTOP is empty.</span>
        <span class="c1">//    - You do not need to make any more calls to page_alloc.</span>
        <span class="c1">//    - Note: In general, pp_ref is not maintained for</span>
        <span class="c1">//      physical pages mapped only above UTOP, but env_pgdir</span>
        <span class="c1">//      is an exception -- you need to increment env_pgdir's</span>
        <span class="c1">//      pp_ref for env_free to work correctly.</span>
        <span class="c1">//    - The functions in kern/pmap.h are handy.</span>

        <span class="c1">// LAB 3: Your code here.</span>
        <span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span> <span class="o">=</span> <span class="p">(</span><span class="n">pde_t</span><span class="o">*</span><span class="p">)</span><span class="n">page2kva</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">pp_ref</span><span class="o">++</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PDX</span><span class="p">(</span><span class="n">UTOP</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                <span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">PDX</span><span class="p">(</span><span class="n">UTOP</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NPDENTRIES</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
                <span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kern_pgdir</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="c1">// UVPT maps the env's own page table read-only.</span>
        <span class="c1">// Permissions: kernel R, user R</span>
        <span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">[</span><span class="n">PDX</span><span class="p">(</span><span class="n">UVPT</span><span class="p">)]</span> <span class="o">=</span> <span class="n">PADDR</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="n">PTE_U</span><span class="p">;</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">region_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">// LAB 3: Your code here.</span>
        <span class="c1">// (But only if you need it for load_icode.)</span>
        <span class="c1">//</span>
        <span class="c1">// Hint: It is easier to use region_alloc if the caller can pass</span>
        <span class="c1">//   'va' and 'len' values that are not page-aligned.</span>
        <span class="c1">//   You should round va down, and round (va + len) up.</span>
        <span class="c1">//   (Watch out for corner-cases!)</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">begin</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ROUNDDOWN</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">va</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ROUNDUP</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">va</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>

        <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vai</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">vai</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">vai</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">page_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                        <span class="n">panic</span><span class="p">(</span><span class="s">"In region_alloc: Page alloc failed."</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">page_insert</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">vai</span><span class="p">,</span> <span class="n">PTE_W</span> <span class="o">|</span> <span class="n">PTE_U</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">panic</span><span class="p">(</span><span class="s">"In region_alloc: Page insert failed."</span><span class="p">);</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">load_icode</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">binary</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">// Hints:</span>
        <span class="c1">//  Load each program segment into virtual memory</span>
        <span class="c1">//  at the address specified in the ELF segment header.</span>
        <span class="c1">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span>
        <span class="c1">//  Each segment's virtual address can be found in ph-&gt;p_va</span>
        <span class="c1">//  and its size in memory can be found in ph-&gt;p_memsz.</span>
        <span class="c1">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span>
        <span class="c1">//  'binary + ph-&gt;p_offset', should be copied to virtual address</span>
        <span class="c1">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span>
        <span class="c1">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span>
        <span class="c1">//  Use functions from the previous lab to allocate and map pages.</span>
        <span class="c1">//</span>
        <span class="c1">//  All page protection bits should be user read/write for now.</span>
        <span class="c1">//  ELF segments are not necessarily page-aligned, but you can</span>
        <span class="c1">//  assume for this function that no two segments will touch</span>
        <span class="c1">//  the same virtual page.</span>
        <span class="c1">//</span>
        <span class="c1">//  You may find a function like region_alloc useful.</span>
        <span class="c1">//</span>
        <span class="c1">//  Loading the segments is much simpler if you can move data</span>
        <span class="c1">//  directly into the virtual addresses stored in the ELF binary.</span>
        <span class="c1">//  So which page directory should be in force during</span>
        <span class="c1">//  this function?</span>
        <span class="c1">//</span>
        <span class="c1">//  You must also do something with the program's entry point,</span>
        <span class="c1">//  to make sure that the environment starts executing there.</span>
        <span class="c1">//  What?  (See env_run() and env_pop_tf() below.)</span>

        <span class="c1">// LAB 3: Your code here.</span>
        <span class="c1">// è¿™æ®µä»£ç å°±åƒ boot loader åšçš„é‚£æ ·</span>
        <span class="c1">// æˆ‘ä»¬éœ€è¦ä¸€ä¸ª ELF äºŒè¿›åˆ¶é•œåƒ</span>
        <span class="k">struct</span> <span class="n">Elf</span> <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Elf</span><span class="o">*</span><span class="p">)</span><span class="n">binary</span><span class="p">;</span>

        <span class="c1">// ç„¶åå°±åƒ bootmain é‡Œåšçš„é‚£æ ·</span>
        <span class="c1">// é¦–å…ˆåˆ¤æ–­è¯»å–çš„ binary æ˜¯ä¸æ˜¯åˆæ³• ELF</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">e_magic</span> <span class="o">!=</span> <span class="n">ELF_MAGIC</span><span class="p">)</span>
                <span class="n">panic</span><span class="p">(</span><span class="s">"binary is not a valid ELF."</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">e_entry</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">panic</span><span class="p">(</span><span class="s">"binary read failed."</span><span class="p">);</span>

        <span class="c1">// è®¾ç½®å…¥å£ç‚¹</span>
        <span class="n">e</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">.</span><span class="n">tf_eip</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">;</span>
        <span class="c1">// åŠ è½½ç”¨æˆ·ç¯å¢ƒé¡µ</span>
        <span class="n">lcr3</span><span class="p">(</span><span class="n">PADDR</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">));</span>

        <span class="c1">// load each program segment</span>
        <span class="k">struct</span> <span class="n">Proghdr</span> <span class="o">*</span><span class="n">ph</span><span class="p">,</span> <span class="o">*</span><span class="n">eph</span><span class="p">;</span>
        <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Proghdr</span><span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">header</span> <span class="o">+</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">));</span>
        <span class="n">eph</span> <span class="o">=</span> <span class="n">ph</span> <span class="o">+</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">eph</span><span class="p">;</span> <span class="o">++</span><span class="n">ph</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">!=</span> <span class="n">ELF_PROG_LOAD</span><span class="p">)</span>
                        <span class="k">continue</span><span class="p">;</span>

                <span class="kt">uintptr_t</span> <span class="n">va</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">binary</span> <span class="o">+</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">;</span>
                <span class="c1">// Allocate ph-&gt;p_memsz bytes using the function we finished before</span>
                <span class="n">region_alloc</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_va</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">);</span>
                <span class="n">memmove</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_va</span><span class="p">,</span> <span class="n">binary</span> <span class="o">+</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">);</span>
                <span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_va</span> <span class="o">+</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">-</span> <span class="n">ph</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Now map one page for the program's initial stack</span>
        <span class="c1">// at virtual address USTACKTOP - PGSIZE.</span>

        <span class="c1">// LAB 3: Your code here.</span>
        <span class="n">region_alloc</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">USTACKTOP</span> <span class="o">-</span> <span class="n">PGSIZE</span><span class="p">),</span> <span class="n">PGSIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">env_create</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">binary</span><span class="p">,</span> <span class="k">enum</span> <span class="n">EnvType</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">// LAB 3: Your code here.</span>
        <span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">new_env</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">env_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_env</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">panic</span><span class="p">(</span><span class="s">"In env_create: env alloc failed"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">load_icode</span><span class="p">(</span><span class="n">new_env</span><span class="p">,</span> <span class="n">binary</span><span class="p">);</span>
        <span class="n">new_env</span><span class="o">-&gt;</span><span class="n">env_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">env_run</span><span class="p">(</span><span class="k">struct</span> <span class="n">Env</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">// Step 1: If this is a context switch (a new environment is running):</span>
        <span class="c1">//         1. Set the current environment (if any) back to</span>
        <span class="c1">//            ENV_RUNNABLE if it is ENV_RUNNING (think about</span>
        <span class="c1">//            what other states it can be in),</span>
        <span class="c1">//         2. Set 'curenv' to the new environment,</span>
        <span class="c1">//         3. Set its status to ENV_RUNNING,</span>
        <span class="c1">//         4. Update its 'env_runs' counter,</span>
        <span class="c1">//         5. Use lcr3() to switch to its address space.</span>
        <span class="c1">// Step 2: Use env_pop_tf() to restore the environment's</span>
        <span class="c1">//         registers and drop into user mode in the</span>
        <span class="c1">//         environment.</span>

        <span class="c1">// Hint: This function loads the new environment's state from</span>
        <span class="c1">//      e-&gt;env_tf.  Go back through the code you wrote above</span>
        <span class="c1">//      and make sure you have set the relevant parts of</span>
        <span class="c1">//      e-&gt;env_tf to sensible values.</span>

        <span class="c1">// LAB 3: Your code here.</span>

        <span class="c1">// Step 1</span>
        <span class="c1">// 1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">curenv</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_status</span> <span class="o">==</span> <span class="n">ENV_RUNNING</span><span class="p">)</span>
                <span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_status</span> <span class="o">=</span> <span class="n">ENV_RUNNABLE</span><span class="p">;</span>
        <span class="c1">// 2</span>
        <span class="n">curenv</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
        <span class="c1">// 3</span>
        <span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_status</span> <span class="o">=</span> <span class="n">ENV_RUNNING</span><span class="p">;</span>
        <span class="c1">// 4</span>
        <span class="o">++</span><span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_runs</span><span class="p">;</span>
        <span class="c1">// 5</span>
        <span class="n">lcr3</span><span class="p">(</span><span class="n">PADDR</span><span class="p">(</span><span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_pgdir</span><span class="p">));</span>

        <span class="c1">// Step 2</span>
        <span class="n">env_pop_tf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curenv</span><span class="o">-&gt;</span><span class="n">env_tf</span><span class="p">);</span>

        <span class="n">panic</span><span class="p">(</span><span class="s">"env_run not yet implemented"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>æœªå®Œæˆï¼Œå…ˆæ”¾ç€ã€‚</p>

<h1 id="å¼•ç”¨">å¼•ç”¨</h1>
:ET