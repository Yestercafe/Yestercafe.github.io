I"Õ><h1 id="æ­£æ–‡">æ­£æ–‡</h1>
<h2 id="å‰è¨€">å‰è¨€</h2>
<p>åœ¨è¿™ä¸ª lab é‡Œ, æˆ‘ä»¬å°†è¦ä¸ºæˆ‘ä»¬çš„æ“ä½œç³»ç»ŸåŠ ä¸Šå†…å­˜ç®¡ç†(memory management)çš„ä»£ç .<br />
å†…å­˜ç®¡ç†æœ‰ä¸¤ä¸ªç»„ä»¶:<br />
ç¬¬ä¸€ä¸ªæ˜¯å†…æ ¸çš„ç‰©ç†å†…å­˜åˆ†é…å™¨(physical memory allocator for kernel), è¿™ä¸ªåˆ†é…å™¨ä»¥ 4096 bytes ä¸ºå­—èŠ‚æ“ä½œ, ä¹Ÿå°±æ˜¯é¡µ(pages)å®½. æˆ‘ä»¬çš„ä»»åŠ¡ç»´æŠ¤è®°å½•é‡Šæ”¾çš„ç‰©ç†é¡µå’Œåˆ†é…çš„ç‰©ç†é¡µ, ä»¥åŠè¿›ç¨‹ä¹‹é—´çš„é¡µå…±äº«æ•°ç›®çš„æ•°æ®ç»“æ„. ç„¶åæˆ‘ä»¬è¿˜éœ€è¦ç¼–å†™åˆ†é…é‡Šæ”¾å†…å­˜çš„æµç¨‹.<br />
ç¬¬äºŒä¸ªæ˜¯è™šæ‹Ÿå†…å­˜(virtual memory), å°† kernel å’Œç”¨æˆ·ç¨‹åºä½¿ç”¨çš„ç‰©ç†å†…å­˜åœ°å€æ˜ å°„åˆ°è™šæ‹Ÿåœ°å€. The x86 hardwareâ€™s memory management unit(MMU) æŒ‡ä»¤ä½¿ç”¨å†…å­˜æ—¶æ—¶è¿›è¡Œæ˜ å°„, æ­¤æ—¶ä¼šç”¨åˆ°ä¸€äº›é¡µè¡¨(a set of page tables). æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯æŒ‰ç…§è¦æ±‚ä¿®æ”¹ JOS å»å®Œæˆ MMU é¡µè¡¨çš„éƒ¨ç½².</p>

<h3 id="getting-started">Getting started</h3>
<p>å…ˆè¦æŠŠ lab2 çš„åˆ†æ”¯æ‹‰ä¸€ä¸‹, ç„¶åæŠŠ lab1 çš„ commit åˆè¿‡æ¥.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ git pull
Already up-to-date.
$ git checkout -b lab2 origin/lab2
Branch lab2 set up to track remote branch lab2 from origin.
Switched to a new branch 'lab2'
$ git merge lab1
Merge made by the 'recursive' strategy.
 kern/console.c |  2 +-
 kern/kdebug.c  |  8 ++++++--
 kern/monitor.c | 22 +++++++++++++++++++++-
 lib/printfmt.c |  7 +++----
 4 files changed, 31 insertions(+), 8 deletions(-)
</code></pre></div></div>
<p>æœ€ååœ¨ <code class="language-plaintext highlighter-rouge">git branch</code> ç¡®è®¤ä¸€ä¸‹åˆ†æ”¯, è¿™æ ·å°±ç®—æ˜¯åšå®Œäº†.</p>

<p>lab2 æ–°åŠ å…¥äº† 5 ä¸ªæºæ–‡ä»¶:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">inc/memlayout.h</code>: æè¿°è™šæ‹Ÿåœ°å€ç©ºé—´çš„å¸ƒå±€.</li>
  <li><code class="language-plaintext highlighter-rouge">kern/pmap.h</code>: ä¸Šé¢è¿™ä¸¤ä¸ªæ–‡ä»¶å®šä¹‰äº† <code class="language-plaintext highlighter-rouge">PageInfo</code> æ•°æ®ç»“æ„, æˆ‘ä»¬è¦ä½¿ç”¨å®ƒå»è·Ÿè¸ªç©ºé—²çš„ç‰©ç†å†…å­˜é¡µ.</li>
  <li><code class="language-plaintext highlighter-rouge">kern/kclock.h</code>:</li>
  <li><code class="language-plaintext highlighter-rouge">kern/kclock.c</code>: æ“ä½œ PC çš„ç”µæ± ä¾›ç”µæ—¶é’Ÿ(battery-backed clock)å’Œ CMOS RAM ç¡¬ä»¶, è¿™é‡Œé¢æœ‰ BIOS è®°å½•çš„ç‰©ç†å†…å­˜é‡å’Œå…¶ä»–çš„ä¸€äº›ä¸œè¥¿.</li>
  <li><code class="language-plaintext highlighter-rouge">kern/pmap.c</code>: è¯»å–è®¾å¤‡ç¡¬ä»¶, è®¡ç®—ç‰©ç†å†…å­˜é‡. ä½†æ˜¯è¿™æ®µä»£ç æ˜¯éœ€è¦æˆ‘ä»¬è‡ªå·±å†™çš„, åº”è¯¥å°±æ˜¯æœ€åçš„å¤§ä½œä¸šäº†.</li>
</ul>

<h3 id="lab-requirements">Lab Requirements</h3>
<p><strong>å®Œæˆæ‰€æœ‰å¸¸è§„ Exercise å’Œè‡³å°‘ä¸€ä¸ª Challenge.</strong> ä¸º lab ç»“å°¾çš„ questions å†™ä¸Šç®€æ˜çš„å›ç­”.</p>

<h2 id="part-1-physical-page-management">Part 1: Physical Page Management</h2>
<p>JOS ä½¿ç”¨ page granularity(é¡µç²’åº¦)æ¥ç®¡ç†ç‰©ç†å†…å­˜, ä»¥ä¾¿å®ƒèƒ½ä½¿ç”¨ MMU å»æ˜ å°„å’Œä¿æŠ¤æ¯ä¸€ä¸ª allocated å†…å­˜å—. <br />
ç»™æˆ‘ä»¬çš„ä»»åŠ¡æ˜¯å®Œæˆç‰©ç†é¡µåˆ†é…å™¨çš„ä»£ç . å®ƒä¼šè·Ÿè¸ªä¸€ä¸ª <code class="language-plaintext highlighter-rouge">struct PageInfo</code> å¯¹è±¡çš„é“¾è¡¨ä¸­çš„ç©ºé—²é¡µ(å¯¹åº”åˆ°ç‰©ç†é¡µ). æˆ‘ä»¬éœ€è¦åœ¨å®Œæˆè™šæ‹Ÿå†…å­˜å®ç°çš„å‰©ä½™éƒ¨åˆ†ä¹‹å‰å®Œæˆç‰©ç†é¡µåˆ†é…å™¨. <br />
å®Œæˆ Exercise 1.<br />
<em>è¯´çœŸçš„, å¥½éš¾, çœŸçš„å¥½éš¾.</em></p>

<h2 id="part-2-virtual-memory">Part 2: Virtual Memory</h2>
<p>å…ˆè¦äº†è§£ x86 ä¿æŠ¤æ¨¡å¼çš„å†…å­˜ç®¡ç†ç»“æ„. è§ Exercise 2.<br />
è™½ç„¶ Exercise 2 æˆ‘ä»¬æ²¡æœ‰å®Œæˆ, ä½†æ˜¯æœ€èµ·ç çŸ¥é“äº†ä¸¤ä¸ªæœ€åŸºæœ¬çš„ x86 çš„å†…å­˜ç®¡ç†æ¡†æ¶: æ®µç¿»è¯‘å’Œé¡µç¿»è¯‘.</p>

<h3 id="virtual-linear-and-physical-addresses">Virtual, Linear and Physical Addresses</h3>
<p>åœ¨ x86 æœ¯è¯­ä¸­, è™šæ‹Ÿåœ°å€ç”±ä¸€ä¸ªæ®µé€‰æ‹©å™¨å’Œä¸€ä¸ªæ®µä¸­å­˜å‚¨çš„ offset ç»„æˆ; çº¿æ€§åœ°å€æ˜¯ç»è¿‡æ®µç¿»è¯‘ä½†æ˜¯æ²¡æœ‰ç»è¿‡é¡µç¿»è¯‘çš„åœ°å€; ç‰©ç†åœ°å€æ˜¯ç»è¿‡äº†æ®µç¿»è¯‘å†ç»è¿‡é¡µç¿»è¯‘(åœ¨ Exercise 2 ä¸­æˆ‘ä»¬çœ‹åˆ°äº†, è¿™ä¸ªæ­¥éª¤å…¶å®æ˜¯å¯é€‰çš„)å¾—åˆ°çš„åœ°å€, æœ€ç»ˆ 
ä»ç¡¬ä»¶æ€»çº¿åˆ°è¾¾ RAM.</p>

<p>æ‰€è°“çš„ offset, æˆ–è€…è¯´æ˜¯ <code class="language-plaintext highlighter-rouge">offset</code>, æ˜¯ä¸€ä¸ª C æŒ‡é’ˆ. åœ¨ <code class="language-plaintext highlighter-rouge">boot/boot.S</code> æˆ‘ä»¬è£…è½½äº†å¯ä»¥é€šè¿‡è®¾å®šæ®µçš„åŸºå€(ä»¬)ä¸º 0 å’Œæœ€é«˜ä¸Šé™ä¸º 0xffffffff æ¥é«˜æ•ˆåœ°åœç”¨æ®µç¿»è¯‘. æ‰€ä»¥ä¼šå½±å“åˆ° selector ä¸èµ·ä½œç”¨ç„¶åçº¿æ€§åœ°å€æ€»æ˜¯ç­‰äºè™šæ‹Ÿå†…å­˜çš„ <code class="language-plaintext highlighter-rouge">offset</code>. åœ¨ lab3 ä¸­æˆ‘ä»¬ä¼šæ›´å¤šåœ°å»å¹²æ¶‰åˆ†æ®µè¡Œä¸º(segmentation)æ¥éƒ¨ç½²æƒåŠ›çº§åˆ«(privilege levels, åœ¨ Exercise 2 ä¸­å‡ºç°äº†, ä½†æ˜¯æˆ‘æ²¡æ[æ‘Šæ‰‹]), ä½†å¯¹äºå†…å­˜ç¿»è¯‘, æˆ‘ä»¬åœ¨æ•´ä¸ª JOS labs ä¸­å¯ä»¥å¿½ç•¥åˆ†æ®µ, ç„¶åä»…ä»…ä¸“æ³¨äºé¡µç¿»è¯‘.<br />
<em>æˆ‘è§‰å¾—æˆ‘å·²ç»åœ¨ä»£æ›¿ Google Translation äººå·¥è¿›è¡Œæœºç¿»äº†.</em></p>

<p>åœ¨ lab 1 çš„ part 3 ä¸­, æˆ‘ä»¬è£…è½½äº†ä¸€ä¸ªç®€å•çš„é¡µè¡¨åœ¨ 0xf0100000 çš„ä½ç½®. è¿™ä¸ªé¡µè¡¨ä»…æ˜ å°„äº† 4 MB çš„å†…å­˜. åœ¨ lab 2 ä¸­æˆ‘ä»¬è¦äº²æ‰‹åœ¨è™šæ‹Ÿåœ°å€ç©ºé—´å¸ƒå±€ä¸­éƒ¨ç½², å°†è¿™ 4 MB æ‰©å±•åˆ°ä»ç‰©ç†å†…å­˜æœ€èµ·å§‹çš„ 256 MB æ˜ å°„åˆ°è™šæ‹Ÿåœ°å€çš„ 0xf0000000, è¿˜æœ‰å…¶ä»–ä¸€äº›è™šæ‹Ÿå†…å­˜åŒºåŸŸ.<br />
è¿›å…¥ Exercise 3.</p>

<p>ä»£ç åœ¨ CPU æ‰§è¡Œçš„åŒæ—¶, æˆ‘ä»¬å°±å¤„äºä¿æŠ¤æ¨¡å¼äº†(ä¹Ÿå°±æ˜¯ <code class="language-plaintext highlighter-rouge">boot/boot.S</code> æœ€å¼€å§‹è¦åšçš„äº‹), åœ¨æ­¤ä¹‹åå°±æ²¡æ³•ç›´æ¥ä½¿ç”¨çº¿æ€§åœ°å€å’Œç‰©ç†åœ°å€äº†(è¿™å°±æ˜¯ qemu æ˜¾ç¤ºç‰©ç†åœ°å€éƒ¨åˆ†ä¸º read-only çš„åŸå› ?). <strong><em>æ‰€æœ‰</em></strong>çš„å†…å­˜å¼•ç”¨éƒ½è¢«ç¿»è¯‘ä½œè™šæ‹Ÿåœ°å€ä¸”ç”± MMU è½¬æ¢, å°±åƒ C æŒ‡é’ˆä¸€æ ·.</p>

<p>æ¥ç€æˆ‘ä»¬ç¨å¾®æ€»ç»“ä¸€ä¸‹åŸæ–‡ä¸­æåˆ°çš„ä¸€äº›ä¿¡æ¯:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">C type</th>
      <th style="text-align: left">Address type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">T*</code></td>
      <td style="text-align: left">Virtual</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">uintptr_t</code></td>
      <td style="text-align: left">Virtual</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">physaddr_t</code></td>
      <td style="text-align: left">Physical</td>
    </tr>
  </tbody>
</table>

<ol>
  <li><code class="language-plaintext highlighter-rouge">uintptr_t</code> å’Œ <code class="language-plaintext highlighter-rouge">physaddr_t</code> éƒ½æ˜¯ <code class="language-plaintext highlighter-rouge">uint32_t</code>, æ‰€ä»¥ä¸éœ€è¦è¿›è¡Œç±»å‹è½¬æ¢.</li>
  <li><code class="language-plaintext highlighter-rouge">uintptr_t</code> å’Œ <code class="language-plaintext highlighter-rouge">physaddr_t</code> éƒ½æ˜¯æ•´æ•°ç±»å‹, æ‰€ä»¥ä¸èƒ½è¿›è¡Œè§£å¼•ç”¨.</li>
  <li>JOS å…è®¸è§£å¼•ç”¨ <code class="language-plaintext highlighter-rouge">uintptr_t</code> é™¤éå…ˆå°†å®ƒè½¬æ¢ä¸ºä¸€ä¸ªæŒ‡é’ˆç±»å‹.</li>
</ol>

<p>è§£ç­” Question 1.<br />
JOS å†…æ ¸æœ‰æ—¶éœ€è¦å»è¯»å–æˆ–è€…ä¿®æ”¹åªçŸ¥é“ç‰©ç†åœ°å€çš„å†…å­˜åŒºåŸŸ, è¿™æ—¶å€™éœ€è¦ä½¿ç”¨<code class="language-plaintext highlighter-rouge">KADDR(pa)</code>å°†ç‰©ç†åœ°å€è½¬æ¢ä¸ºè™šæ‹Ÿåœ°å€. è¿™ä¸ªæ“ä½œå…¶å®å°±æ˜¯å°†ç‰©ç†åœ°å€åŠ ä¸Š 0xf0000000. ç›¸åçš„æƒ…å†µä¹Ÿæœ‰, è¿™æ—¶ä½¿ç”¨<code class="language-plaintext highlighter-rouge">PADDR(pa)</code>å°†è™šæ‹Ÿåœ°å€è½¬æ¢ä¸ºç‰©ç†åœ°å€.</p>

<h3 id="reference-counting">Reference Counting</h3>
<p>åœ¨ä¹‹åçš„ lab é‡Œè¿™ç»å¸¸å°†ç›¸åŒçš„ç‰©ç†é¡µåŒæ—¶æ˜ å°„åœ¨å¤šä¸ªè™šæ‹Ÿåœ°å€ä¸Š, è¿™æ—¶å€™å°±éœ€è¦ç”¨åˆ° <code class="language-plaintext highlighter-rouge">struct PageInfo</code> çš„ <code class="language-plaintext highlighter-rouge">pp_ref</code> åŸŸæ¥è¿›è¡Œå¼•ç”¨è®¡æ•°, å½“è®¡æ•°é‡ä¸º 0 æ—¶è¿™ä¸ªé¡µæ‰å¯ä»¥è¢«é‡Šæ”¾.</p>

<h3 id="page-table-management">Page Table Management</h3>
<p>è§ Exercise 4.</p>

<h2 id="part-3-kernel-address-space">Part 3. Kernel Address Space</h2>
<p>JOS kernel å°†çº¿æ€§åœ°å€ç©ºé—´åˆ†å‰²æˆäº†ä¸¤ä¸ªéƒ¨åˆ†, ç”¨æˆ·ç¯å¢ƒæ§åˆ¶ä½åœ°å€çš„éƒ¨åˆ†, kernel æ§åˆ¶é«˜åœ°å€çš„éƒ¨åˆ†. å…¶åˆ†ç•Œçº¿åœ¨ <code class="language-plaintext highlighter-rouge">inc/memlayout.h</code> ä¸­å®šä¹‰ä½œ <code class="language-plaintext highlighter-rouge">ULIM</code>, ä¸º kernel ä¿ç•™å¤§çº¦ 256 MB çš„è™šæ‹Ÿåœ°å€ç©ºé—´. è¿™ä¹Ÿå°±æ˜¯åœ¨ lab 1 ä¸­å°† kernel æ”¾åœ¨ä¸€ä¸ªé«˜åœ°å€çš„åŸå› äº†: ç»™ç”¨æˆ·æä¾›è¶³å¤Ÿçš„ç©ºé—´.</p>

<p><code class="language-plaintext highlighter-rouge">inc/memlayout.h</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * Virtual memory map:                                Permissions
 *                                                    kernel/user
 *
 *    4 Gig --------&gt;  +------------------------------+
 *                     |                              | RW/--
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     :              .               :
 *                     :              .               :
 *                     :              .               :
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
 *                     |                              | RW/--
 *                     |   Remapped Physical Memory   | RW/--
 *                     |                              | RW/--
 *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+
 *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                 PTSIZE
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     :              .               :                   |
 *                     :              .               :                   |
 *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+
 *                     |       Memory-mapped I/O      | RW/--  PTSIZE
 * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000
 *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
 *    UVPT      ----&gt;  +------------------------------+ 0xef400000
 *                     |          RO PAGES            | R-/R-  PTSIZE
 *    UPAGES    ----&gt;  +------------------------------+ 0xef000000
 *                     |           RO ENVS            | R-/R-  PTSIZE
 * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000
 * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebff000
 *                     |       Empty Memory (*)       | --/--  PGSIZE
 *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000
 *                     |      Normal User Stack       | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebfd000
 *                     |                              |
 *                     |                              |
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     .                              .
 *                     .                              .
 *                     .                              .
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 *                     |     Program Data &amp; Heap      |
 *    UTEXT --------&gt;  +------------------------------+ 0x00800000
 *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE
 *                     |                              |
 *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+
 *                     |       Empty Memory (*)       |                   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |  User STAB Data (optional)   |                 PTSIZE
 *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |
 *                     |       Empty Memory (*)       |                   |
 *    0 ------------&gt;  +------------------------------+                 --+
 *
 * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
 *     "Empty Memory" is normally unmapped, but user programs may map pages
 *     there if desired.  JOS user programs map pages temporarily at UTEMP.
 */
</code></pre></div></div>
<p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°, åœ¨ ULIM ä¸‹é¢å°±æ˜¯é¡µè¡¨ç©ºé—´. ULIM ä»¥ä¸Šçš„, æ‹¿ 0x100000000 å‡å» 0xef800000 ç­‰äº 0x10800000, å…¶ä¸­é è¿‘ ULIM çš„ 4 MB(PTSIZE)æ˜¯å†…æ ¸çš„åŒºåŸŸ, å†å¾€ä¸Šçš„å°±æ˜¯ 0xf0000000~0x100000000 çš„ 256 MB ç©ºé—´.</p>

<h3 id="permissions-and-fault-isolation">Permissions and Fault Isolation</h3>
<p>x86 é¡µè¡¨ä½¿ç”¨äº†æƒé™ä½æ¥æ§åˆ¶ç”¨æˆ·çš„å¯è®¿é—®æ€§, è¿™ä¸ªæˆ‘ä»¬åœ¨ Exercise 4 é‡Œä¹Ÿç€å®çœ‹åˆ°äº†. å…¶ä¸­çš„ <code class="language-plaintext highlighter-rouge">PTE_W</code> å°±æ˜¯ç”¨æ¥æ§åˆ¶ kernel å†™æƒé™çš„, <code class="language-plaintext highlighter-rouge">PTE_U</code> æ˜¯ç”¨æ¥æ§åˆ¶ç”¨æˆ·æƒé™çš„.<br />
ç”¨æˆ·ç¯å¢ƒå¯¹äº ULIM ä»¥å‡çš„å†…å­˜æ²¡æœ‰æƒé™, ä½†æ˜¯ kernel å¯ä»¥å¯¹è¿™å†…å­˜è¿›è¡Œè¯»å†™. å¯¹äºèŒƒå›´ <code class="language-plaintext highlighter-rouge">[UTOP,ULIM)</code>, ç”¨æˆ·ç¯å¢ƒå’Œ kernel åº”æœ‰ç›¸åŒçš„æƒé™, è¿™ä¸ªæˆ‘ä»¬åœ¨ <code class="language-plaintext highlighter-rouge">inc/memlayout.h</code> é‡Œä¹Ÿçœ‹åˆ°äº†. ç„¶å UTOP ä»¥é™çš„åœ°å€å°±æ˜¯ä¸“é—¨ç»™ç”¨æˆ·ç¯å¢ƒä½¿ç”¨çš„äº†, ä¸å†å¤šæäº†.</p>

<h3 id="initializing-the-kernel-address-space">Initializing the Kernel Address Space</h3>
<p>åœ¨ Exercise 5 å®ç°åˆšæ‰æåˆ°çš„ä¸œè¥¿.</p>

<h3 id="address-space-layout-alternatives">Address Space Layout Alternatives</h3>
<p>æˆ‘ä»¬åœ¨ JOS ä¸­ä½¿ç”¨çš„å†…å­˜å¸ƒå±€åªæ˜¯ä¸€ç§å®ç°, å…¶ä»–çš„æ“ä½œç³»ç»Ÿä¹Ÿå¯ä»¥å°†ä½åœ°å€åŒºåŸŸä¿ç•™ç»™æ“ä½œç³»ç»Ÿ, é«˜åœ°å€åŒºåŸŸç»™ç”¨æˆ·ç¯å¢ƒ. ä¸è¿‡, å› ä¸ºè¦è€ƒè™‘åˆ°ä¸€ä¸ª x86 å‘åå…¼å®¹æ€§æ¨¡å¼, å«åš virtual 8086 mode, å¤„ç†å™¨ç¡¬ä»¶ä¸­å†™æ­»äº†ä¼šä½¿ç”¨çº¿æ€§åœ°å€ç©ºé—´çš„åº•éƒ¨ç©ºé—´, äºæ˜¯å†…æ ¸å³ä½¿æœ‰æ˜ å°„é‚£ä¸ªéƒ¨åˆ†ä¹Ÿæ— æ³•ä½¿ç”¨.</p>

<h1 id="question">Question</h1>
<h2 id="question-1">Question 1</h2>
<blockquote>
  <p>Assuming that the following JOS kernel code is correct, what type should variable <code class="language-plaintext highlighter-rouge">x</code> have, <code class="language-plaintext highlighter-rouge">uintptr_t</code> or <code class="language-plaintext highlighter-rouge">physaddr_t</code>?</p>
  <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">mystery_t</span> <span class="n">x</span><span class="p">;</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">value</span> <span class="o">=</span> <span class="n">return_a_pointer</span><span class="p">();</span>
	<span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">mystery_t</span><span class="p">)</span> <span class="n">value</span><span class="p">;</span>
</code></pre></div>  </div>
</blockquote>

<p>è¿™é‡Œæˆ‘çŒœæµ‹æ˜¯<code class="language-plaintext highlighter-rouge">uintptr_t</code>, å› ä¸ºå‰æ–‡æåˆ°è¿‡åœ¨è¿›å…¥ä¿æŠ¤æ¨¡å¼ä¹‹åæ— æ³•ä¿®æ”¹ç‰©ç†åœ°å€? ç±»ä¼¼çš„ä»£ç ç¨ååº”è¯¥èƒ½åœ¨ Exercise 4 ä¸­çœ‹åˆ°. 
äº‹å®è¯æ˜è¿™æ˜¯å¯¹çš„.</p>

<h2 id="question-2">Question 2</h2>
<blockquote>
  <p>What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:</p>
</blockquote>

<p>é—®é¡µç›®å½•é‡Œæœ‰ä»€ä¹ˆ, è¿™å…¶å®æ²¡å•¥å¥½è¯´çš„, <code class="language-plaintext highlighter-rouge">inc/memlayout.h</code> é‡Œè¯´çš„å·²ç»å¾ˆæ¸…æ¥šäº†.</p>

<h2 id="question-3">Question 3</h2>
<blockquote>
  <p>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernelâ€™s memory? What specific mechanisms protect the kernel memory?</p>
</blockquote>

<p>å¦‚æœç”¨æˆ·ç¨‹åºèƒ½å¤Ÿè¯»å†™å†…æ ¸, åæœå°†ä¸å ªè®¾æƒ³å¥½å§. <br />
ç‰¹æ®Šæœºåˆ¶? æƒé™ä½çš„è®¾ç½®.</p>

<h2 id="question-4">Question 4</h2>
<blockquote>
  <p>What is the maximum amount of physical memory that this operating system can support? Why?</p>
</blockquote>

<p>æœ€å¤§æ”¯æŒçš„ç‰©ç†å†…å­˜é‡, ä¸çŸ¥é“, ä¸ä¼š.</p>

<h2 id="question-5">Question 5</h2>
<blockquote>
  <p>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p>
</blockquote>

<h2 id="question-6">Question 6</h2>
<blockquote>
  <p>Revisit the page table setup in <code class="language-plaintext highlighter-rouge">kern/entry.S</code> and <code class="language-plaintext highlighter-rouge">kern/entrypgdir.c</code>. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p>
</blockquote>

<p>åœ¨ lab 1 çš„ Exercise 6 ä¸­, æˆ‘ä»¬å¯ä»¥çœ‹åˆ°:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) b *0x7d6b
Breakpoint 1 at 0x7d6b
(gdb) c
Continuing.
The target architecture is assumed to be i386
=&gt; 0x7d6b:	call   *0x10018
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">boot/main.c:60</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="p">(</span><span class="n">ELFHDR</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">))();</span>
</code></pre></div></div>
<p>æ£€æŸ¥è¿‡äº†, ç¡®å®æ˜¯è¿™é‡Œè·³è½¬çš„.</p>

<h1 id="exercise">Exercise</h1>
<h2 id="exercise-1">Exercise 1</h2>
<blockquote>
  <p><strong>Exercise 1.</strong> In the file <code class="language-plaintext highlighter-rouge">kern/pmap.c</code>, you must implement code for the following functions (probably in the order given).</p>

  <p><code class="language-plaintext highlighter-rouge">boot_alloc()</code><br />
<code class="language-plaintext highlighter-rouge">mem_init()</code> (only up to the call to <code class="language-plaintext highlighter-rouge">check_page_free_list(1)</code>)<br />
<code class="language-plaintext highlighter-rouge">page_init()</code><br />
<code class="language-plaintext highlighter-rouge">page_alloc()</code><br />
<code class="language-plaintext highlighter-rouge">page_free()</code></p>

  <p><code class="language-plaintext highlighter-rouge">check_page_free_list()</code> and <code class="language-plaintext highlighter-rouge">check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether <code class="language-plaintext highlighter-rouge">check_page_alloc()</code> reports success. Fix your code so that it passes. You may find it helpful to add your own <code class="language-plaintext highlighter-rouge">assert()</code>s to verify that your assumptions are correct.</p>
</blockquote>

<p>æŒ‰å…ˆåæ¬¡åºå®ç°è¿™äº›å‡½æ•°. <br />
<code class="language-plaintext highlighter-rouge">boot_alloc()</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This simple physical memory allocator is used only while JOS is setting</span>
<span class="c1">// up its virtual memory system.  page_alloc() is the real allocator.</span>
<span class="c1">//</span>
<span class="c1">// If n&gt;0, allocates enough pages of contiguous physical memory to hold 'n'</span>
<span class="c1">// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.</span>
<span class="c1">//</span>
<span class="c1">// If n==0, returns the address of the next free page without allocating</span>
<span class="c1">// anything.</span>
<span class="c1">//</span>
<span class="c1">// If we're out of memory, boot_alloc should panic.</span>
<span class="c1">// This function may ONLY be used during initialization,</span>
<span class="c1">// before the page_free_list list has been set up.</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">boot_alloc</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">nextfree</span><span class="p">;</span>	<span class="c1">// virtual address of next byte of free memory</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>

	<span class="c1">// Initialize nextfree if this is the first time.</span>
	<span class="c1">// 'end' is a magic symbol automatically generated by the linker,</span>
	<span class="c1">// which points to the end of the kernel's bss segment:</span>
	<span class="c1">// the first virtual address that the linker did *not* assign</span>
	<span class="c1">// to any kernel code or global variables.</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nextfree</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">extern</span> <span class="kt">char</span> <span class="n">end</span><span class="p">[];</span>
		<span class="n">nextfree</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">end</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// Allocate a chunk large enough to hold 'n' bytes, then update</span>
	<span class="c1">// nextfree.  Make sure nextfree is kept aligned</span>
	<span class="c1">// to a multiple of PGSIZE.</span>
	<span class="c1">//</span>
	<span class="c1">// LAB 2: Your code here.</span>

	<span class="c1">// If n&gt;0, allocates enough pages of contiguous physical memory to hold 'n'</span>
	<span class="c1">// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">new_nextfree</span> <span class="o">=</span> <span class="n">ROUNDUP</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">nextfree</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
		<span class="c1">// If alloc failed</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_nextfree</span> <span class="o">&lt;</span> <span class="n">nextfree</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">"Alloc failed."</span><span class="p">);</span>
		<span class="c1">// If we're out of memory, boot_alloc should panic.</span>
        <span class="c1">// è¿™é‡Œçš„ `PADDR` å‚è€ƒäº†å­Ÿä½¬çš„æ–‡ç« </span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PADDR</span><span class="p">(</span><span class="n">new_nextfree</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x40000000</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">"Out of memory."</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">nextfree</span><span class="p">;</span>
		<span class="n">nextfree</span> <span class="o">=</span> <span class="n">new_nextfree</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// If n==0, returns the address of the next free page without allocating</span>
	<span class="c1">// anything.</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">nextfree</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>éƒ¨åˆ†ä»£ç å‚è€ƒäº†å­Ÿä½¬çš„æ–‡ç« <a href="#ref1">$^1$</a>.<br />
<code class="language-plaintext highlighter-rouge">mem_init()</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Set up a two-level page table:</span>
<span class="c1">//    kern_pgdir is its linear (virtual) address of the root</span>
<span class="c1">//</span>
<span class="c1">// This function only sets up the kernel part of the address space</span>
<span class="c1">// (ie. addresses &gt;= UTOP).  The user part of the address space</span>
<span class="c1">// will be set up later.</span>
<span class="c1">//</span>
<span class="c1">// From UTOP to ULIM, the user is allowed to read but not write.</span>
<span class="c1">// Above ULIM the user cannot read or write.</span>
<span class="kt">void</span>
<span class="nf">mem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cr0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>

	<span class="c1">// Find out how much memory the machine has (npages &amp; npages_basemem).</span>
	<span class="n">i386_detect_memory</span><span class="p">();</span>

	<span class="c1">// Remove this line when you're ready to test this function.</span>
    <span class="c1">// å®Œæˆäº†è¿™é‡Œæ³¨é‡Šæ‰</span>
	<span class="c1">// panic("mem_init: This function is not finished\n");</span>

	<span class="c1">//////////////////////////////////////////////////////////////////////</span>
	<span class="c1">// create initial page directory.</span>
	<span class="n">kern_pgdir</span> <span class="o">=</span> <span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">boot_alloc</span><span class="p">(</span><span class="n">PGSIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>

	<span class="c1">//////////////////////////////////////////////////////////////////////</span>
	<span class="c1">// Recursively insert PD in itself as a page table, to form</span>
	<span class="c1">// a virtual page table at virtual address UVPT.</span>
	<span class="c1">// (For now, you don't have understand the greater purpose of the</span>
	<span class="c1">// following line.)</span>

	<span class="c1">// Permissions: kernel R, user R</span>
	<span class="n">kern_pgdir</span><span class="p">[</span><span class="n">PDX</span><span class="p">(</span><span class="n">UVPT</span><span class="p">)]</span> <span class="o">=</span> <span class="n">PADDR</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_U</span> <span class="o">|</span> <span class="n">PTE_P</span><span class="p">;</span>

	<span class="c1">//////////////////////////////////////////////////////////////////////</span>
	<span class="c1">// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.</span>
	<span class="c1">// The kernel uses this array to keep track of physical pages: for</span>
	<span class="c1">// each physical page, there is a corresponding struct PageInfo in this</span>
	<span class="c1">// array.  'npages' is the number of physical pages in memory.  Use memset</span>
	<span class="c1">// to initialize all fields of each struct PageInfo to 0.</span>
	<span class="c1">// Your code goes here:</span>
    <span class="c1">// npages æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡, ç”± `i386_detect_memory()` ç¡®å®š. </span>
	<span class="n">pages</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="p">)</span><span class="n">boot_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">PageInfo</span><span class="p">)</span> <span class="o">*</span> <span class="n">npages</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">PageInfo</span><span class="p">)</span> <span class="o">*</span> <span class="n">npages</span><span class="p">);</span>

	<span class="c1">//////////////////////////////////////////////////////////////////////</span>
	<span class="c1">// Now that we've allocated the initial kernel data structures, we set</span>
	<span class="c1">// up the list of free physical pages. Once we've done so, all further</span>
	<span class="c1">// memory management will go through the page_* functions. In</span>
	<span class="c1">// particular, we can now map memory using boot_map_region</span>
	<span class="c1">// or page_insert</span>
	<span class="n">page_init</span><span class="p">();</span>

	<span class="n">check_page_free_list</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">check_page_alloc</span><span class="p">();</span>
	<span class="n">check_page</span><span class="p">();</span>

	<span class="c1">//////////////////////////////////////////////////////////////////////</span>
	<span class="c1">// Now we set up virtual memory</span>

	<span class="c1">//////////////////////////////////////////////////////////////////////</span>
	<span class="c1">// Map 'pages' read-only by the user at linear address UPAGES</span>
	<span class="c1">// Permissions:</span>
	<span class="c1">//    - the new image at UPAGES -- kernel R, user R</span>
	<span class="c1">//      (ie. perm = PTE_U | PTE_P)</span>
	<span class="c1">//    - pages itself -- kernel RW, user NONE</span>
	<span class="c1">// Your code goes here:</span>

	<span class="c1">//////////////////////////////////////////////////////////////////////</span>
	<span class="c1">// Use the physical memory that 'bootstack' refers to as the kernel</span>
	<span class="c1">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span>
	<span class="c1">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span>
	<span class="c1">// to be the kernel stack, but break this into two pieces:</span>
	<span class="c1">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span>
	<span class="c1">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span>
	<span class="c1">//       the kernel overflows its stack, it will fault rather than</span>
	<span class="c1">//       overwrite memory.  Known as a "guard page".</span>
	<span class="c1">//     Permissions: kernel RW, user NONE</span>
	<span class="c1">// Your code goes here:</span>

	<span class="c1">//////////////////////////////////////////////////////////////////////</span>
	<span class="c1">// Map all of physical memory at KERNBASE.</span>
	<span class="c1">// Ie.  the VA range [KERNBASE, 2^32) should map to</span>
	<span class="c1">//      the PA range [0, 2^32 - KERNBASE)</span>
	<span class="c1">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span>
	<span class="c1">// we just set up the mapping anyway.</span>
	<span class="c1">// Permissions: kernel RW, user NONE</span>
	<span class="c1">// Your code goes here:</span>

	<span class="c1">// Check that the initial page directory has been set up correctly.</span>
	<span class="n">check_kern_pgdir</span><span class="p">();</span>

	<span class="c1">// Switch from the minimal entry page directory to the full kern_pgdir</span>
	<span class="c1">// page table we just created.	Our instruction pointer should be</span>
	<span class="c1">// somewhere between KERNBASE and KERNBASE+4MB right now, which is</span>
	<span class="c1">// mapped the same way by both page tables.</span>
	<span class="c1">//</span>
	<span class="c1">// If the machine reboots at this point, you've probably set up your</span>
	<span class="c1">// kern_pgdir wrong.</span>
	<span class="n">lcr3</span><span class="p">(</span><span class="n">PADDR</span><span class="p">(</span><span class="n">kern_pgdir</span><span class="p">));</span>

	<span class="n">check_page_free_list</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="c1">// entry.S set the really important flags in cr0 (including enabling</span>
	<span class="c1">// paging).  Here we configure the rest of the flags that we care about.</span>
	<span class="n">cr0</span> <span class="o">=</span> <span class="n">rcr0</span><span class="p">();</span>
	<span class="n">cr0</span> <span class="o">|=</span> <span class="n">CR0_PE</span><span class="o">|</span><span class="n">CR0_PG</span><span class="o">|</span><span class="n">CR0_AM</span><span class="o">|</span><span class="n">CR0_WP</span><span class="o">|</span><span class="n">CR0_NE</span><span class="o">|</span><span class="n">CR0_MP</span><span class="p">;</span>
	<span class="n">cr0</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">CR0_TS</span><span class="o">|</span><span class="n">CR0_EM</span><span class="p">);</span>
	<span class="n">lcr0</span><span class="p">(</span><span class="n">cr0</span><span class="p">);</span>

	<span class="c1">// Some more checks, only possible after kern_pgdir is installed.</span>
	<span class="n">check_page_installed_pgdir</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">page_init()</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --------------------------------------------------------------</span>
<span class="c1">// Tracking of physical pages.</span>
<span class="c1">// The 'pages' array has one 'struct PageInfo' entry per physical page.</span>
<span class="c1">// Pages are reference counted, and free pages are kept on a linked list.</span>
<span class="c1">// --------------------------------------------------------------</span>

<span class="c1">//</span>
<span class="c1">// Initialize page structure and memory free list.</span>
<span class="c1">// After this is done, NEVER use boot_alloc again.  ONLY use the page</span>
<span class="c1">// allocator functions below to allocate and deallocate physical</span>
<span class="c1">// memory via the page_free_list.</span>
<span class="c1">//</span>
<span class="kt">void</span>
<span class="nf">page_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// The example code here marks all physical pages as free.</span>
	<span class="c1">// However this is not truly the case.  What memory is free?</span>
	<span class="c1">//  1) Mark physical page 0 as in use.</span>
	<span class="c1">//     This way we preserve the real-mode IDT and BIOS structures</span>
	<span class="c1">//     in case we ever need them.  (Currently we don't, but...)</span>
	<span class="c1">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span>
	<span class="c1">//     is free.</span>
	<span class="c1">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span>
	<span class="c1">//     never be allocated.</span>
	<span class="c1">//  4) Then extended memory [EXTPHYSMEM, ...).</span>
	<span class="c1">//     Some of it is in use, some is free. Where is the kernel</span>
	<span class="c1">//     in physical memory?  Which pages are already in use for</span>
	<span class="c1">//     page tables and other data structures?</span>
	<span class="c1">//</span>
	<span class="c1">// Change the code to reflect this.</span>
	<span class="c1">// NB: DO NOT actually touch the physical memory corresponding to</span>
	<span class="c1">// free pages!</span>
	<span class="cm">/*
	struct PageInfo {
		// Next page on the free list.
		struct PageInfo *pp_link;

		// pp_ref is the count of pointers (usually in page table entries)
		// to this page, for pages allocated using page_alloc.
		// Pages allocated at boot time using pmap.c's
		// boot_alloc do not have valid reference count fields.

		uint16_t pp_ref;
	};
	*/</span>

	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="c1">// 1) Mark physical page 0 as in use.</span>
	<span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="c1">// 2) The rest of base memory. </span>
	<span class="c1">// [PGSIZE, npages_basemem * PGSIZE)</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages_basemem</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_link</span> <span class="o">=</span> <span class="n">page_free_list</span><span class="p">;</span>
		<span class="n">page_free_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="c1">// 3) The IO hole.</span>
	<span class="c1">// [IOPHYSMEM, EXTPHYSMEM)</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EXTPHYSMEM</span> <span class="o">/</span> <span class="n">PGSIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// 4) Extended memory.</span>
	<span class="c1">// [EXTPHYSMEM, ...)</span>
	<span class="kt">size_t</span> <span class="n">first_free_page_idx</span> <span class="o">=</span> <span class="n">PADDR</span><span class="p">(</span><span class="n">boot_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="n">PGSIZE</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">first_free_page_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pp_link</span> <span class="o">=</span> <span class="n">page_free_list</span><span class="p">;</span>
		<span class="n">page_free_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>éƒ¨åˆ†å‚è€ƒäº†ç½‘å‹å®Œæˆçš„ 6.828 JOS ä»£ç <a href="#ref2">$^2$</a>.<br />
<code class="language-plaintext highlighter-rouge">page_alloc()</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span>
<span class="nf">page_alloc</span><span class="p">(</span><span class="kt">int</span> <span class="n">alloc_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Fill this function in</span>
	<span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">alloc_page</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_free_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">alloc_page</span> <span class="o">=</span> <span class="n">page_free_list</span><span class="p">;</span>
	<span class="n">page_free_list</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="o">-&gt;</span><span class="n">pp_link</span><span class="p">;</span>
	<span class="n">alloc_page</span><span class="o">-&gt;</span><span class="n">pp_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">&amp;</span> <span class="n">ALLOC_ZERO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">page2kva</span><span class="p">(</span><span class="n">alloc_page</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">alloc_page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">page2kva()</code> å‡½æ•°å¯ä»¥å°† page çš„åœ°å€è½¬æ¢ä¸º kernel virtual address. è¿™æ®µæ˜¯æˆ‘è ¢äº†, æ²¡çœ‹å…¶ä»–çš„äººçš„æ–‡ç« çœŸçš„æ²¡æƒ³åˆ°.<br />
<code class="language-plaintext highlighter-rouge">page_free()</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">page_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">pp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// Fill this function in</span>
	<span class="c1">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span>
	<span class="c1">// pp-&gt;pp_link is not NULL.</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_ref</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">"pp-&gt;pp_ref is nonzero."</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_link</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">"pp-&gt;pp_link is not NULL."</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_link</span> <span class="o">=</span> <span class="n">page_free_list</span><span class="p">;</span>
	<span class="n">page_free_list</span> <span class="o">=</span> <span class="n">pp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>è¿™äº”ä¸ªå‡½æ•°å†™èµ·æ¥å…¶å®ä¸æ˜¯å¾ˆéš¾, åªæ˜¯ç”¨åˆ°äº†ä¸€äº›å®å‘€å‡½æ•°å‘€å…¨å±€å˜é‡å‘€ä¸æ˜¯ç‰¹åˆ«ç†Ÿæ‚‰, å‚è€ƒäº†ä¸€äº›èµ„æ–™åå®Œæˆåå†æ¥çœ‹ä»£ç ç€å®æ˜¯éå¸¸ç®€å•, æ‰€è°“çš„é“¾è¡¨æ•°æ®ç»“æ„ä¹Ÿå°±åªæ˜¯æœ€ç®€å•çš„ push å’Œ pop æ“ä½œ. <br />
ä¸­é—´å‡ºäº†ä¸€äº›æ²¡æœ‰è½¬æ¢æˆç‰©ç†åœ°å€çš„é—®é¢˜, éƒ½ç”¨ <code class="language-plaintext highlighter-rouge">assert(0)</code> æ–­ç‚¹(è‡³ä»Šè¿˜æ˜¯ä¸ä¹ æƒ¯ç”¨ gdb è°ƒè¯•)å¤„ç†å¥½äº†.<br />
æ³¨æ„, è¿™é‡Œåªéœ€è¦è¿‡ <code class="language-plaintext highlighter-rouge">check_page_free_list()</code> å’Œ <code class="language-plaintext highlighter-rouge">check_page_alloc()</code> å°±è¡Œäº†, <code class="language-plaintext highlighter-rouge">check_page()</code> æš‚æ—¶è¿‡ä¸äº†.</p>

<h2 id="exercise-2">Exercise 2</h2>
<blockquote>
  <p><strong>Exercise 2.</strong> Look at chapters 5 and 6 of <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">the Intel 80386 Reference Manual</a>, if you havenâ€™t done so already. Read the sections about page translation and page-based protection closely (5.2 and 6.4). We recommend that you also skim the sections about segmentation; while JOS uses the paging hardware for virtual memory and protection, segment translation and segment-based protection cannot be disabled on the x86, so you will need a basic understanding of it.</p>
</blockquote>

<p>è¯»æ–‡æ¡£.</p>
<h3 id="chapter-5">Chapter 5</h3>
<p>å¼€å¤´ä¸€å¼ å›¾å‘Šè¯‰æˆ‘ä»¬, logical address(åˆ†å‰²æˆ selector å’Œ offset, è¿™ä¸ªæˆ‘ä»¬åœ¨ NASM æ‰‹å†Œé‡Œå·²ç»æåˆ°è¿‡äº†)å…ˆè¿›è¡Œ segment translation, è¿™é‡Œéœ€è¦åˆ¤æ–­ä¸€ä¸ª paging æ ‡è®°æ˜¯å¦å¼€å¯, å¦‚æœå¼€å¯é‚£ä¹ˆç¿»è¯‘å‡ºæ¥çš„ç›´æ¥å°±æ˜¯ physical address; å¦‚æœå…³é—­, åˆ™ç¿»è¯‘æˆ linear address, å†é€šè¿‡ page translation ç¿»è¯‘æˆ physical address.</p>

<h4 id="51-segment-translation">5.1 Segment Translation</h4>
<p>å®ç°è¿™ä¸ªç¿»è¯‘è¿‡ç¨‹, å¤„ç†å™¨ä¼šä½¿ç”¨ä¸‹é¢çš„æ•°æ®ç»“æ„:</p>
<ul>
  <li>Descriptors (æè¿°ç¬¦)</li>
  <li>Descriptor tables (æè¿°ç¬¦è¡¨, å§‘ä¸”è®¤å®šä¸ºé“¾è¡¨)</li>
  <li>Selectors (é€‰æ‹©å™¨)</li>
  <li>Segment Registers (æ®µå¯„å­˜å™¨)</li>
</ul>

<h5 id="511-descriptors">5.1.1 Descriptors</h5>
<p>æ®µæè¿°ç¬¦ä¸ºå¤„ç†å™¨æä¾›äº†ä»é€»è¾‘åœ°å€åˆ°çº¿æ€§åœ°å€çš„æ˜ å°„æ•°æ®, æè¿°ç¬¦ç”±ç¼–è¯‘å™¨/é“¾æ¥èµ·/åŠ è½½å™¨/æ“ä½œç³»ç»Ÿåˆ›å»º, å¹¶éåº”ç”¨ç¨‹åºç¨‹åºå‘˜. æ®µæè¿°ç¬¦æœ‰ä¸¤ä¸ªæ ¼å¼, æ¯”è¾ƒå¤æ‚å°±ä¸è®¨è®ºäº†, ä½†ä¸¤ä¸ªæ ¼å¼éƒ½æ˜¯å  32 ä½.</p>

<h5 id="512-descriptor-tables">5.1.2 Descriptor Tables</h5>
<p>æ®µæè¿°ç¬¦å¿…è¢«å­˜å‚¨åœ¨ä¸‹é¢ä¸¤ä¸ªè¡¨ä¸­å…¶ä¸­ä¸€ä¸ª:</p>
<ul>
  <li>The global descriptor table (GDT)</li>
  <li>A local descriptor table (LDT)</li>
</ul>

<p>æè¿°ç¬¦è¡¨æ˜¯éå¸¸ç®€æ˜“çš„ç”± 8 å­—èŠ‚ entry(å…¶ä¸­åŒ…å«æè¿°ç¬¦)ä¸ºå•ä½çš„å†…å­˜æ•°ç»„. è¡¨çš„ç©ºé—´æ˜¯å¯å˜çš„, æœ€å¤§å¯ä»¥å®¹çº³ 8192 ä¸ªæè¿°ç¬¦. GDT çš„ç¬¬ä¸€ä¸ª entry ä¸è¢«å¤„ç†å™¨ä½¿ç”¨.</p>

<p>å¤„ç†å™¨æä¾›äº† GDTR å’Œ LDTR ä¸¤ä¸ªå¯„å­˜å™¨å­˜å‚¨ä¸¤è¡¨çš„åŸºå€(çº¿æ€§åœ°å€ç©ºé—´çš„)å’Œæ®µä¸Šé™. <code class="language-plaintext highlighter-rouge">LGDT</code>, <code class="language-plaintext highlighter-rouge">SGDT</code>, <code class="language-plaintext highlighter-rouge">LLDT</code>, <code class="language-plaintext highlighter-rouge">SLDT</code> å››ä¸ªæŒ‡ä»¤åˆ†åˆ«ç”¨æ¥æ§åˆ¶ GDT å’Œ LDT çš„ load å’Œ set.</p>

<h5 id="513-selectors">5.1.3 Selectors</h5>
<p>é€»è¾‘åœ°å€é€‰æ‹©å™¨é€šè¿‡æŒ‡å®šæè¿°ç¬¦è¡¨å’Œåœ¨è¡¨ä¸­å»ºç«‹ç´¢å¼•æ¥æ ‡è¯†æè¿°ç¬¦. é€‰æ‹©å™¨å¯ä½œä¸ºä¸€ä¸ªæŒ‡é’ˆåŸŸå¯¹åº”ç”¨ç¨‹åºå¯è§, ä½†æ˜¯å…¶å€¼é€šå¸¸è¢«é“¾æ¥å™¨æˆ–é“¾æ¥åŠ è½½å™¨èµ‹äºˆ. ä¸€ä¸ª selector å  16 ä¸ªä½.</p>

<h5 id="514-segment-registers">5.1.4 Segment Registers</h5>
<p>80386 åœ¨æ®µå¯„å­˜å™¨ä¸­å­˜å‚¨æ¥è‡ªæè¿°ç¬¦çš„ä¿¡æ¯, ä½¿ç”¨å¯„å­˜å™¨ä»è€Œé¿å…å‚è€ƒæè¿°è¡¨æ—¶æ¯æ¬¡éƒ½è¦è®¿é—®å†…å­˜. <br />
æ¯ä¸€ä¸ªæ®µå¯„å­˜å™¨éƒ½æœ‰å¯è§†å’Œä¸å¯è§†çš„éƒ¨åˆ†. åœ¨ lab1 ä¸­æˆ‘ä»¬å°±æœ‰ä»å”çš„æ–‡ç« ä¸­ç›—äº†ä¸€äº›èµ„æ–™, æ®µå¯„å­˜å™¨é™¤äº† CS å’Œ SS å¤–, è¿˜æœ‰ DS, ES, FS, GS çš„é¢å¤–æ®µå¯„å­˜å™¨. è¿™ 6 ä¸ªå¯„å­˜å™¨ä¼šè¢«çœ‹ä½œæ˜¯ 16 ä½å¯„å­˜å™¨, ä½†å…¶å®å®ƒä»¬çš„åé¢è¿˜æœ‰å¾ˆå¤§ä¸€ä¸ªåŒºåŸŸ(çœ‹å›¾ä¾‹è‡³å°‘æ¯” 16 ä½å¤§ä¸¤å€)æ˜¯ç”±å¤„ç†å™¨æ§åˆ¶è€Œä¸å¯è§çš„.<br />
è¯»å–è¿™äº›å¯„å­˜å™¨çš„æŒ‡ä»¤åˆ†ä¸ºä¸¤ç±»:</p>
<ol>
  <li>ç›´æ¥(direct)è¯»å–æŒ‡ä»¤: å¦‚ <code class="language-plaintext highlighter-rouge">MOV</code>, <code class="language-plaintext highlighter-rouge">POP</code>, <code class="language-plaintext highlighter-rouge">LDS</code>, <code class="language-plaintext highlighter-rouge">LSS</code>, <code class="language-plaintext highlighter-rouge">LGS</code>, <code class="language-plaintext highlighter-rouge">LFS</code>.</li>
  <li>é—´æ¥(implied)è¯»å–æŒ‡ä»¤: å¦‚ far <code class="language-plaintext highlighter-rouge">CALL</code> å’Œ <code class="language-plaintext highlighter-rouge">JMP</code>.</li>
</ol>

<p>ä¸ç®¡æ˜¯å“ªç§, å®ƒä»¬éƒ½ä¼šä½¿ç”¨ 16 ä½é€‰æ‹©å™¨å»è¯»å…¥å¯„å­˜å™¨çš„å¯è§†éƒ¨åˆ†. å¤„ç†å™¨è‡ªåŠ¨ä»æè¿°ç¬¦è¡¨ä¸­è·å–åŸºå€, ä¸Šé™, ç±»å‹å’Œå…¶ä»–ä¿¡æ¯å¹¶å°†ä»–ä»¬åŠ è½½åˆ°æ®µå¯„å­˜å™¨çš„å¯è§†éƒ¨åˆ†.</p>

<h4 id="52-page-translation">5.2 Page Translation</h4>
<p>åœ°å€ç¿»è¯‘çš„ç¬¬äºŒé˜¶æ®µ, å°†çº¿æ€§åœ°å€ç¿»è¯‘æˆç‰©ç†åœ°å€. è¿™ä¸ªé˜¶æ®µéœ€è¦å®ç°é¢å‘é¡µçš„è™šæ‹Ÿå†…å­˜ç³»ç»Ÿå’Œé¡µçº§ä¿æŠ¤ç­‰åŸºæœ¬åŠŸèƒ½.<br />
é¡µç¿»è¯‘çš„æ­¥éª¤æ˜¯å¯é€‰çš„, è¿™æ ·çœ‹ CR0 çš„ PG bit æ˜¯å¦è¢«ç½®ä½. å‚è€ƒ lab1 çš„ Exercise 7.</p>

<h5 id="521-page-frame">5.2.1 Page Frame</h5>
<p>é¡µå¸§æ˜¯ 4kB ç‰©ç†å†…å­˜è¿ç»­åœ°å€å•ä½. é¡µçš„èµ·å§‹åœ°å€å—é™(æˆ‘ä»¬åœ¨ä¹‹å‰çš„ä»£ç ä¸­ä¹Ÿè§åˆ°è¿‡äº†), å¹¶ä¸”å®šé•¿.</p>

<h5 id="522-linear-address">5.2.2 Linear Address</h5>
<p>ç”± DIR, PAGE å’Œ OFFSET ä¸‰ä¸ªåŸŸç»„æˆ. å¯»å€æœºåˆ¶æ˜¯ä¸€ä¸ªäºŒçº§ç´¢å¼•æ–¹å¼. å…ˆä½¿ç”¨ DIR ä½œä¸ºç´¢å¼•å¥—å‡ºä¸€ä¸ªé¡µç›®å½•, å†ä½¿ç”¨ PAGE ä½œä¸ºç´¢å¼•å¥—å‡ºå•ä¸ªé¡µè¡¨, æœ€åå† offset.</p>

<h5 id="523-page-tables">5.2.3 Page Tables</h5>
<p>é¡µè¡¨æ˜¯ä¸€ä¸ªç®€æ˜“çš„ 32 ä½é¡µè¯´æ˜ç¬¦(specifier)æ•°ç»„. é¡µè¡¨æœ¬èº«å°±æ˜¯é¡µ, æ„æ€å°±æ˜¯å®ƒæœ‰ 4KiB çš„å†…å­˜, æ„æ€å°±æ˜¯å¯ä»¥ä¿å­˜å¤§æ¦‚ 1k çš„ 32 ä½é¡¹ç›®. <br />
é¡µè¡¨åŒæ ·æ˜¯ç”¨äºŒçº§ç´¢å¼•. ä¸Šå±‚ç´¢å¼•æ˜¯ä¸€ä¸ªé¡µç›®å½•, è¿™ä¸ªç›®å½•å¯ä»¥ç´¢å¼•åˆ°ä¸€ä¸ª 1k é¡µè¡¨. ä¸‹å±‚ç´¢å¼•æ˜¯ 1k é¡µè¡¨, å¯ä»¥æ‰€å¼•å¯¼ä¸€ä¸ª 1k é¡µ. æ‰€æœ‰çš„é¡µè¡¨è¢«ä¸€ä¸ªé¡µç›®å½•å¯»å€, æ‰€ä»¥æ€»å…±å¯ä»¥å¯»å€ 1m($2^{20}$) ä¸ªé¡µ. å› ä¸ºä¸€ä¸ªé¡µåŒ…å« 4kB, æ‰€ä»¥é¡µç›®å½•è¡¨æ€»å…±å ç‰©ç†å†…å­˜çš„ $2^32$ ä¸ªå­—èŠ‚*(æŒ‡80386).</p>

<h5 id="524-page-table-entries">5.2.4 Page-Table Entries</h5>
<ul>
  <li>Page Frame Address, å› ä¸ºé¡µæœ‰ 4k çš„è¾¹ç•Œ, æ‰€ä»¥è¿™ä¸ªåœ°å€çš„ä½ 12 ä½æ€»æ˜¯ 0. åœ¨ä¸åŒçš„åœºåˆ page frame address å¯ä»¥è¡¨ç¤ºä¸åŒçš„å«ä¹‰.</li>
  <li>Present Bit, æŒ‡ç¤ºé¡µè¡¨é¡¹æ˜¯å¦å¯ä»¥è¢«è¿›è¡Œ address translation. P=1 æŒ‡å¯ä»¥.</li>
  <li>Accessed and Dirty Bits, è¿™äº›ä¸ºæä¾›æ¯ä¸€çº§é¡µè¡¨çš„é¡µä½¿ç”¨æƒ…å†µçš„æ•°æ®.</li>
  <li>Read/Write and User/Supervisor Bits, ä¸åœ¨ address translation ä¸­ä½¿ç”¨, ç”¨äºé¡µçº§ä¿æŠ¤.</li>
</ul>

<h5 id="525-page-translation-cache">5.2.5 Page Translation Cache</h5>
<p>ä¸ºä¿è¯åœ°å€ç¿»è¯‘çš„æé«˜æ•ˆ, å¤„ç†å™¨ä¼šå°†æœ€è¿‘ä½¿ç”¨çš„é¡µè¡¨æ•°æ®å­˜è¿›èŠ¯ç‰‡ç¼“å­˜(on-chip cache)ä¸­, ä½¿ç”¨åˆ°çš„ç›¸å…³å¯„å­˜å™¨æ˜¯ CR3.</p>

<h4 id="53-combining-segment-and-page-translation">5.3 Combining Segment and Page Translation</h4>
<p>è·³è¿‡.</p>

<h3 id="chapter-6-protection">Chapter 6 Protection</h3>
<h4 id="61-why-protection">6.1 Why Protection?</h4>
<p>ä¿æŠ¤åŠŸèƒ½å¯ä»¥å¸®åŠ© 80386 æ£€æµ‹å’Œè¯†åˆ« bugs. 80386 æ”¯æŒå¯èƒ½ç”±æˆç™¾ä¸Šåƒæ¨¡å—ç»„æˆçš„å¤æ‚åº”ç”¨ç¨‹åº, è¿™å…¶ä¸­å®šå°‘ä¸äº†ä¸€äº›å†²çª. 80386 çš„æœºåˆ¶ä¼šæŒ‰ç…§ä¿æŠ¤æ ‡å‡†ç¬¦åˆæ€§(conformance to protection criteria)éªŒè¯å†…å­˜è®¿é—®å’ŒæŒ‡ä»¤æ‰§è¡Œ.<br />
ä¸€å®šè¦æ³¨æ„, è¿™äº›æœºè´¨ä¼šå› ç³»ç»Ÿè®¾è®¡ç›®çš„è€Œè¢«ä½¿ç”¨æˆ–è€…å¿½ç•¥.</p>

<h4 id="62-overview-of-80386-protection-mechanisms">6.2 Overview of 80386 Protection Mechanisms</h4>
<p>80386 çš„ä¿æŠ¤åˆ†ä¸ºäº”ç±»:</p>
<ul>
  <li>Type checking ç±»å‹æ£€æŸ¥</li>
  <li>Limit checking èŒƒå›´æ£€æŸ¥</li>
  <li>Restriction of addressable domain å¯å¯»å€åŸŸé™åˆ¶</li>
  <li>Restriction of procedure entry points å‡½æ•°å…¥å£ç‚¹é™åˆ¶</li>
  <li>Restriction of instruction set æŒ‡ä»¤é›†é™åˆ¶</li>
</ul>

<h4 id="63-segment-level-protection">6.3 Segment-Level Protection</h4>
<p>ä¸Šé¢é‚£ 5 ä¸ªä¿æŠ¤è·Ÿè¿™ä¸€çº§éƒ½æœ‰å…³. 
ä¿æŠ¤æ£€æµ‹ä¼šåœ¨ä¸€ä¸ªæ®µæè¿°ç¬¦çš„é€‰æ‹©å™¨è¢«è¯»å–è¿›æ®µå¯„å­˜å™¨åŒæ—¶è¿›è¡Œæ¯ä¸€ä¸ªæ®µè®¿é—®æ—¶è¢« CPU è‡ªåŠ¨æ‰§è¡Œ. æ®µå¯„å­˜å™¨æŒæœ‰å½“å‰å¯å¯»å€æ®µçš„ä¿æŠ¤å‚æ•°. åŸè¯:</p>
<blockquote>
  <p>Protection checks are performed automatically by the CPU when the selector of a segment descriptor is loaded into a segment register and with every segment access. Segment registers hold the protection parameters of the currently addressable segments.</p>
</blockquote>

<p><em>æˆ‘è‡ªå·±éƒ½ä¸çŸ¥é“æˆ‘ç¿»è¯‘äº†ä¸ªå•¥.</em></p>

<p>åé¢çš„ä¸çœ‹äº†, æˆ‘ä¸æƒ³æ´»äº†. æ‰€ä»¥è¿™ä¸ª Exercise æ²¡æœ‰å®Œæˆ.</p>

<h2 id="exercise-3">Exercise 3</h2>
<blockquote>
  <p>Exercise 3. While GDB can only access QEMUâ€™s memory by virtual address, itâ€™s often useful to be able to inspect physical memory while setting up virtual memory. Review the QEMU <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu">monitor commands</a> from the lab tools guide, especially the <code class="language-plaintext highlighter-rouge">xp</code> command, which lets you inspect physical memory. To access the QEMU monitor, press <code class="language-plaintext highlighter-rouge">Ctrl-a c</code> in the terminal (the same binding returns to the serial console).</p>

  <p>Use the <code class="language-plaintext highlighter-rouge">xp</code> command in the QEMU monitor and the <code class="language-plaintext highlighter-rouge">x</code> command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.</p>

  <p>Our patched version of QEMU provides an <code class="language-plaintext highlighter-rouge">info pg</code> command that may also prove useful: it shows a compact but detailed representation of the current page tables, including all mapped memory ranges, permissions, and flags. Stock QEMU also provides an <code class="language-plaintext highlighter-rouge">info mem</code> command that shows an overview of which ranges of virtual addresses are mapped and with what permissions.</p>
</blockquote>

<p>å­—å¾ˆå¤šä½†æ˜¯æ²¡å•¥å†…å®¹. æˆ‘ä»¬ä½¿ç”¨å¿«æ·é”®è°ƒå‡º qemu çš„å‘½ä»¤è¡Œçœ‹ä¸€ä¸‹æŒ‡ä»¤çš„è¾“å‡ºç»“æœ.</p>

<p>ç¬¬ä¸€ä¸ª, æˆ‘ä»¬å¼€ gdb, æ–­ç‚¹æ‰“åœ¨ kernel çš„å…¥å£.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(gdb) x/8x 0xf0100000
0xf0100000 &lt;_start+4026531828&gt;:	0x1badb002	0x00000000	0xe4524ffe	0x7205c766
0xf0100010 &lt;entry+4&gt;:	0x34000004	0x2000b812	0x220f0011	0xc0200fd8
(gdb) x/8x 0x00100000
0x100000:	0x1badb002	0x00000000	0xe4524ffe	0x7205c766
0x100010:	0x34000004	0x2000b812	0x220f0011	0xc0200fd8
</code></pre></div></div>
<p>è¿˜æ˜¯å¾ˆç†Ÿæ‚‰çš„æ•°æ®, æˆ‘ä»¬çœ‹ä¸‹ qemu é‚£è¾¹:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(qemu) xp 0xf0100000
00000000f0100000: 0x00000000
(qemu) xp 0x00100000
0000000000100000: 0x1badb002
</code></pre></div></div>
<p>ä½†æ˜¯ qemu è¿™è¾¹çœ‹ä¸åˆ°, æˆ‘ä¹Ÿä¸çŸ¥é“æ˜¯ä¸ºå•¥.</p>

<p>ç¬¬äºŒä¸ª, å› ä¸ºæˆ‘ä»¬çš„ qemu ä½¿ç”¨ apt è£…çš„, æ‰€ä»¥æ²¡æœ‰ 828 patch çš„æŒ‡ä»¤, å°±ä½¿ç”¨ <code class="language-plaintext highlighter-rouge">info mem</code> çœ‹ä¸‹å¥½äº†.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(qemu) info mem
0000000000000000-0000000000400000 0000000000400000 -r-
00000000f0000000-00000000f0400000 0000000000400000 -rw
</code></pre></div></div>
<p>ä¸Šé¢åº”è¯¥æ˜¯ç‰©ç†å†…å­˜çš„ 0x000000~0x400000 çš„åŒºåŸŸ, æ˜ å°„åˆ°è™šæ‹Ÿåœ°å€çš„ 0xf0000000~0xf0400000 16 MB çš„åŒºåŸŸ. 
æ³¨æ„ç‰©ç†åœ°å€çš„é¦– 16 MB åŒºåŸŸåªæœ‰è¯»æƒé™, è€Œè™šæ‹Ÿå†…å­˜çš„å¯¹åº”åŒºåŸŸæœ‰å†™æƒé™.</p>

<p>æŒ‰å”çš„æ–‡ç« <a href="#ref3">$^3$</a>çš„è¯´æ³•, ä½¿ç”¨æ‰‹å†Œé‡Œç»™çš„å¿«æ·é”®æ— æ³•æ‰“å¼€ qemu monitor. æˆ‘åœ¨ Google æœç´¢ qemu <code class="language-plaintext highlighter-rouge">xp</code> æŒ‡ä»¤çš„é—®é¢˜æ—¶, çœ‹åˆ°äº†å¦å¤–ä¸€ä½å¤§ä½¬çš„æ–‡ç« <a href="#ref4">$^4$</a>é‡Œæœ‰ç›¸å…³è”çš„è§£å†³æ–¹æ¡ˆ:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>qemu-system-i386 <span class="nt">-hda</span> obj/kern/kernel.img <span class="nt">-monitor</span> stdio <span class="nt">-gdb</span> tcp::26000 <span class="nt">-D</span> qemu.log
</code></pre></div></div>
<p>ä¸è¿‡æˆ‘æ²¡æœ‰å‡ºç°è¿™ä¸ªé—®é¢˜.</p>

<h2 id="exercise-4">Exercise 4</h2>
<blockquote>
  <p>Exercise 4. In the file <code class="language-plaintext highlighter-rouge">kern/pmap.c</code>, you must implement code for the following functions.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        pgdir_walk()
        boot_map_region()
        page_lookup()
        page_remove()
        page_insert()
</code></pre></div>  </div>
  <p><code class="language-plaintext highlighter-rouge">check_page()</code>, called from <code class="language-plaintext highlighter-rouge">mem_init()</code>, tests your page table management routines. You should make sure it reports success before proceeding.</p>
</blockquote>

<p><strong>å¼ºè°ƒ, è¿™é¢˜åªéœ€è¦è¿‡ <code class="language-plaintext highlighter-rouge">check_page()</code>!!</strong>, åˆè¢«å‘äº†ä¸€æ¬¡!</p>

<p>ç¨å¾®æ€»ç»“ä¸€ä¸‹, é¦–å…ˆ, <code class="language-plaintext highlighter-rouge">pde_t</code> å’Œ <code class="language-plaintext highlighter-rouge">pte_t</code> åˆ†åˆ«è¡¨ç¤º Page Directory Entry å’Œ Page Table Entry. <br />
æ¯”å¦‚ <code class="language-plaintext highlighter-rouge">pgdir_walk()</code> å‡½æ•°, è¿™ä¸ªå‡½æ•°çš„ç›®çš„æ˜¯åˆ©ç”¨ <code class="language-plaintext highlighter-rouge">va</code> çº¿æ€§åœ°å€ä¸º <code class="language-plaintext highlighter-rouge">pgdir</code> è¿™æ ·ä¸€ä¸ªé¡µç›®å½•è¿›è¡Œç´¢å¼•. çº¿æ€§åœ°å€çš„ç»“æ„æ—©åœ¨ Exercise 2 ä¸­å°±å‡ºç°è¿‡, ä½†æ˜¯å› ä¸ºè¿™ç¯‡æ–‡ç« é‡Œæ²¡æœ‰æ”¾å‡ºé‚£å¼ å›¾ç‰‡, å½“æ—¶è§‰å¾—å¯èƒ½ä¸æ˜¯ä»€ä¹ˆå¾ˆé‡è¦çš„ä¸œè¥¿, å°±æ²¡æƒ³åˆ°è¿™é‡Œå°±ç”¨åˆ°äº†. çº¿æ€§åœ°å€çš„é«˜ 10 ä½æ˜¯ Page Directory Index, è¾ƒé«˜ 10 ä½æ˜¯ Page Table Index, äºæ˜¯ç†æ‰€å½“ç„¶, æˆ‘ä»¬çš„å¯»å€åº”è¯¥æ˜¯ç±»ä¼¼ <code class="language-plaintext highlighter-rouge">pgdir[PDX(va)][PTX(va)]</code> è¿™æ ·çš„, è¿›è¡Œä¸€äº›ç»†åˆ™çš„åˆ†è§£, å°±å˜æˆäº† <code class="language-plaintext highlighter-rouge">*(*(pgdir + PDX(va)) + PTX(va))</code>. æ ¹æ® Exercise 2 ä¸­è¯´çš„, å…¶å®ä¸ç®¡æ˜¯ç›®å½•è¿˜æ˜¯é¡µè¡¨, è¿™ä¸­é—´çš„æ¯ä¸€å±‚éƒ½æ˜¯ä¸€ä¸ªé¡µ. åœ¨ <code class="language-plaintext highlighter-rouge">pgdir_walk()</code> ä¸­, æˆ‘ä»¬é¦–å…ˆä½¿ç”¨äº† <code class="language-plaintext highlighter-rouge">PTE_P</code> flag å»åˆ¤æ–­äº† <code class="language-plaintext highlighter-rouge">pde</code> å¼•ç”¨çš„ç›®å½•æ˜¯å¦å­˜åœ¨, å¦‚æœå­˜åœ¨åˆ™ç›´æ¥å°†å…¶è½¬æ¢ä¸º PTE çš„åœ°å€, æœ€åè¿”å› PTE çš„é¦–åœ°å€åŠ ä¸Šä¸€ä¸ª <code class="language-plaintext highlighter-rouge">offset</code>(è¿™é‡Œå°±æ˜¯ <code class="language-plaintext highlighter-rouge">PTX(va)</code>), å®Œæˆè¿™ä¸ªäºŒçº§ç´¢å¼•; å¦‚æœä¸å­˜åœ¨, ä¸­é—´åŠ ä¸Šä¸€ä¸ªåˆ›å»ºè¿™ä¸€ä¸ªç›®å½•çš„è¿‡ç¨‹, åˆ›å»ºä¸€ä¸ª <code class="language-plaintext highlighter-rouge">PageInfo</code> å…¶å®ä¹Ÿå°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„é¡µ, ç„¶åä½¿ç”¨ <code class="language-plaintext highlighter-rouge">page2pa()</code> å°†é¡µä¿¡æ¯å¯¹è±¡è½¬æ¢ä¸ºå…¶å¯¹åº”çš„ç‰©ç†åœ°å€. æ³¨æ„, PDE é‡Œå­˜çš„éƒ½æ˜¯ PTE çš„ kernel è™šæ‹Ÿåœ°å€. <br />
å†å°±æ˜¯ <code class="language-plaintext highlighter-rouge">page_lookup()</code>, è¿”å›é¡µåœ¨ <code class="language-plaintext highlighter-rouge">va</code> å¤„æ˜ å°„çš„è™šæ‹Ÿåœ°å€. é¦–å…ˆä½¿ç”¨ <code class="language-plaintext highlighter-rouge">pgdir_walk()</code> ç»è¿‡ä¸€æ¬¡äºŒçº§å¯»å€æ‰¾åˆ° PTE çš„åœ°å€, è€Œåå†æ£€æŸ¥ PTE å¼•ç”¨çš„å†…å®¹. <br />
<code class="language-plaintext highlighter-rouge">page_remove()</code> å’Œ <code class="language-plaintext highlighter-rouge">page_insert()</code> çš„åŠŸèƒ½æ›´åƒæ˜¯ STL æ™ºèƒ½æŒ‡é’ˆçš„å·¥ä½œ, è¿›è¡Œè§£é™¤å¼•ç”¨å’Œå¼•ç”¨(è¿™é‡Œå«è§£é™¤æ˜ å°„å’Œæ˜ å°„). å¤§è‡´çš„åŠŸèƒ½ä¸ç”¨å¤šè¯´äº†, insert å°±æ˜¯æ™®é€šçš„æ’å…¥, å¦‚æœåŸä½ç½®å·²ç»è¢«å ç”¨äº†, å°±å…ˆå°†åŸæ¥çš„é¡µæ˜ å°„è§£é™¤æ‰; remove å°±æ˜¯è§£é™¤ä¸€æ¬¡å¼•ç”¨, å¦‚æœé¡µä¸å†è¢«å¼•ç”¨, å°±ä½¿ç”¨ <code class="language-plaintext highlighter-rouge">page_free()</code> å°†å…¶é‡Šæ”¾æ‰, å½“ç„¶è¿™ä¸ªéƒ¨åˆ†å·²ç»è¢« <code class="language-plaintext highlighter-rouge">page_decref()</code> æ‰˜ç®¡äº†.</p>

<p>ä¸‹é¢æ˜¯å››å¤„æ‹¼å‡‘æ¥çš„ä»£ç :</p>

<p><code class="language-plaintext highlighter-rouge">pgdir_walk()</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pte_t</span> <span class="o">*</span>
<span class="nf">pgdir_walk</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgdir</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// A linear address 'la' has a three-part structure as follows:</span>
	<span class="c1">//</span>
	<span class="c1">// +--------10------+-------10-------+---------12----------+</span>
	<span class="c1">// | Page Directory |   Page Table   | Offset within Page  |</span>
	<span class="c1">// |      Index     |      Index     |                     |</span>
	<span class="c1">// +----------------+----------------+---------------------+</span>
	<span class="c1">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span>
	<span class="c1">//  \---------- PGNUM(la) ----------/</span>
	<span class="c1">//</span>
	<span class="c1">// The PDX, PTX, PGOFF, and PGNUM macros decompose linear addresses as shown.</span>
	<span class="c1">// To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),</span>
	<span class="c1">// use PGADDR(PDX(la), PTX(la), PGOFF(la)).</span>
	<span class="n">pde_t</span> <span class="o">*</span><span class="n">pde</span> <span class="o">=</span> <span class="n">pgdir</span> <span class="o">+</span> <span class="n">PDX</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
	<span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pde</span> <span class="o">&amp;</span> <span class="n">PTE_P</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span><span class="o">*</span><span class="p">)</span><span class="n">KADDR</span><span class="p">(</span><span class="n">PTE_ADDR</span><span class="p">(</span><span class="o">*</span><span class="n">pde</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">create</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// If (alloc_flags &amp; ALLOC_ZERO), fills the entire returned physical page with '\0' bytes.</span>
			<span class="c1">// ALLOC_ZERO == 1 &lt;&lt; 0;</span>
			<span class="c1">// è¿™é‡Œå‚æ•°å¡«å†™ ALLOC_ZERO, æ˜¯ä¸ºäº†ä½¿ç”¨ memset å¯¹é¡µè¿›è¡Œå¡«å……</span>
			<span class="k">struct</span> <span class="n">PageInfo</span><span class="o">*</span> <span class="n">page_info</span> <span class="o">=</span> <span class="n">page_alloc</span><span class="p">(</span><span class="n">ALLOC_ZERO</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page_info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="c1">// å¼•ç”¨è®¡æ•°å¢åŠ </span>
			<span class="c1">// æ³¨æ„æˆ‘ä»¬åœ¨ç¼–å†™ page_alloc() å‡½æ•°çš„æ—¶å€™, ä¸Šé¢æœ‰æ³¨é‡Šæç¤ºæˆ‘ä»¬</span>
			<span class="c1">// ä¸è¦å¢åŠ å¼•ç”¨è®¡æ•°çš„</span>
			<span class="n">page_info</span><span class="o">-&gt;</span><span class="n">pp_ref</span><span class="o">++</span><span class="p">;</span>
			<span class="o">*</span><span class="n">pde</span> <span class="o">=</span> <span class="n">page2pa</span><span class="p">(</span><span class="n">page_info</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="n">PTE_W</span> <span class="o">|</span> <span class="n">PTE_U</span><span class="p">;</span>
			<span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span><span class="o">*</span><span class="p">)</span><span class="n">KADDR</span><span class="p">(</span><span class="n">PTE_ADDR</span><span class="p">(</span><span class="o">*</span><span class="n">pde</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// create == false, åˆ™ä½œä¸åˆ›å»ºç›´æ¥è¿”å› NULL</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pte</span> <span class="o">+</span> <span class="n">PTX</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">boot_map_region()</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span>
<span class="nf">boot_map_region</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">va</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">physaddr_t</span> <span class="n">pa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">va</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">pa</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pte_t</span><span class="o">*</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pgdir_walk</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">va</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">"pgdir_walk failed in boot_map_region"</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">|</span> <span class="n">perm</span> <span class="o">|</span> <span class="n">PTE_P</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">page_lookup()</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span>
<span class="nf">page_lookup</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="n">pte_t</span> <span class="o">**</span><span class="n">pte_store</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// æŸ¥æ‰¾ pte, å¦‚æœæ²¡æ‰¾åˆ°ä¸è¿›è¡Œåˆ›å»º</span>
	<span class="n">pte_t</span><span class="o">*</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pgdir_walk</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte_store</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">pte_store</span> <span class="o">=</span> <span class="n">pte</span><span class="p">;</span>	
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_P</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">pa2page</span><span class="p">(</span><span class="n">PTE_ADDR</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">page_remove()</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">page_remove</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span><span class="o">*</span> <span class="n">pte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">PageInfo</span><span class="o">*</span> <span class="n">page_info</span> <span class="o">=</span> <span class="n">page_lookup</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pte</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="n">page_decref</span><span class="p">(</span><span class="n">page_info</span><span class="p">);</span>

	
	<span class="c1">// page_info-&gt;pp_ref--;</span>
	<span class="c1">// if (page_info-&gt;pp_ref == 0) {</span>
	<span class="c1">// 	page_free(page_info);</span>
	<span class="c1">// }</span>
	
	<span class="n">tlb_invalidate</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">page_insert</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">page_insert</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">PageInfo</span> <span class="o">*</span><span class="n">pp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pte_t</span><span class="o">*</span> <span class="n">pte</span> <span class="o">=</span> <span class="n">pgdir_walk</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pte</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E_NO_MEM</span><span class="p">;</span>

	<span class="n">pp</span><span class="o">-&gt;</span><span class="n">pp_ref</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_P</span><span class="p">)</span>
		<span class="n">page_remove</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">va</span><span class="p">);</span>

	<span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">page2pa</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="o">|</span> <span class="n">perm</span> <span class="o">|</span> <span class="n">PTE_P</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="exercise-5">Exercise 5</h2>
<blockquote>
  <p><strong>Exercise 5.</strong> Fill in the missing code in <code class="language-plaintext highlighter-rouge">mem_init()</code> after the call to <code class="language-plaintext highlighter-rouge">check_page()</code>.</p>

  <p>Your code should now pass the <code class="language-plaintext highlighter-rouge">check_kern_pgdir()</code> and <code class="language-plaintext highlighter-rouge">check_page_installed_pgdir()</code> checks.</p>
</blockquote>

<p>In <code class="language-plaintext highlighter-rouge">kern/pmap.c:186</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	//////////////////////////////////////////////////////////////////////
	// Now we set up virtual memory

	//////////////////////////////////////////////////////////////////////
	// Map 'pages' read-only by the user at linear address UPAGES
	// Permissions:
	//    - the new image at UPAGES -- kernel R, user R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
	// æ³¨æ„å†…å­˜å¯¹é½
	boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U);

	//////////////////////////////////////////////////////////////////////
	// Use the physical memory that 'bootstack' refers to as the kernel
	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
	// to be the kernel stack, but break this into two pieces:
	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
	// 
	// KSTKSIZE æ˜¯ kernel æ ˆçš„å¤§å°, åˆ«æé”™äº†
	boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);

	//////////////////////////////////////////////////////////////////////
	// Map all of physical memory at KERNBASE.
	// Ie.  the VA range [KERNBASE, 2^32) should map to
	//      the PA range [0, 2^32 - KERNBASE)
	// We might not have 2^32 - KERNBASE bytes of physical memory, but
	// we just set up the mapping anyway.
	// Permissions: kernel RW, user NONE
	// Your code goes here:
	// åŒºåŸŸæ˜¯ [KERNBASE, 0xffffffff], æƒé™æ˜¯ PTE_W
	boot_map_region(kern_pgdir, KERNBASE, 0xffffffff-KERNBASE, 0, PTE_W);

	// Check that the initial page directory has been set up correctly.
	check_kern_pgdir();
</code></pre></div></div>
<p>åšåˆ° Exercise 5 æˆ‘æ‰çŸ¥é“è¿™ä¸ª lab åˆ°åº•è¦å¹²å˜›. å‰é¢çš„å‡½æ•°çš„å®ç°, å…¨æ˜¯ä¸ºæœ€åä¸€ä¸ªéƒ¨åˆ†å‡†å¤‡çš„.</p>

<h1 id="challenge">Challenge!</h1>
<p><strong>æéš¾è­¦å‘Š!</strong><br />
<em>å› ä¸ºéº»çƒ¦äº†å°±ä¸åšäº†, å…¶å®æ˜¯æ‡’.</em></p>

<h1 id="æ€»ç»“">æ€»ç»“</h1>
<p>ä¸­é—´å› ä¸ºæœ‰ç‚¹äº‹è€½è¯¯äº†ä¸€ä¸ªå¤šæ˜ŸæœŸ, åŠ ä¸Šè‡ªå·±å·äº†ç‚¹æ‡’.<br />
ä¸ªäººè§‰å¾—è¿™ä¸ªå®éªŒæ¯”å®éªŒ 1 è¦éš¾, è‡ªå·±ä¹Ÿæ˜¯å¾ˆå¤šä¸œè¥¿éƒ½æ²¡ææ‡‚, æœ€åçš„ questions ä¹Ÿæ²¡æœ‰éƒ½ç­”ä¸Šæ¥. ä¸è¿‡å¤§ä½“ä¸Šå¯¹è™šæ‹Ÿå†…å­˜, é¡µè¡¨, å†…å­˜ç®¡ç†çš„çŸ¥è¯†æœ‰äº†ä¸€äº›å®è§‚çš„è®¤è¯†. 
Challenge çœ‹ç€å¤´ç–¼æ²¡åšäº†.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./grade-lab2
running JOS: <span class="o">(</span>1.4s<span class="o">)</span> 
  Physical page allocator: OK 
  Page management: OK 
  Kernel page directory: OK 
  Page management 2: OK 
Score: 70/70
</code></pre></div></div>

<h1 id="å¼•ç”¨">å¼•ç”¨</h1>
<ol>
  <li><span id="ref1">https://zhuanlan.zhihu.com/p/41871340</span></li>
  <li><span id="ref2">https://github.com/SmallPond/MIT6.828_OS/blob/master/lab/kern/pmap.c</span></li>
  <li><span id="ref3">https://github.com/Spdwal/LearningLanuages/blob/master/OperatingSystem/Lab2.md</span></li>
  <li><span id="ref4">https://xinqiu.me/2016/12/09/MIT-6.828-2</span></li>
</ol>
:ET